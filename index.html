<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Az…ôrbaycan Damasƒ± (Dama)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        /* Custom Keyframes and Classes for Visual Appeal */
        @keyframes pulse-fast {
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 113, 133, 0.7); }
            50% { box-shadow: 0 0 15px 15px rgba(251, 113, 133, 0.5); }
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        .animate-pulse-fast { animation: pulse-fast 1s infinite cubic-bezier(0.4, 0, 0.6, 1); }
        .animate-flicker { animation: flicker 0.5s infinite alternate; }
        .title-glow { text-shadow: 0 0 10px #f97316, 0 0 20px #f97316; }
        .button-glow { transition: all 0.3s; box-shadow: 0 0 10px rgba(236, 72, 153, 0.5); }
        .button-glow:hover { box-shadow: 0 0 20px rgba(236, 72, 153, 0.8); }

        .board {
            display: grid;
            grid-template-columns: repeat(8, min(11vw, 55px));
            grid-template-rows: repeat(8, min(11vw, 55px));
            border: 8px solid #334155;
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            overflow: hidden;
            touch-action: manipulation;
            margin: 0 auto;
        }
        .cell {
            width: min(11vw, 55px);
            height: min(11vw, 55px);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s;
        }
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 2px solid;
        }
        .piece-white { background-color: #fff; color: #1f2937; border-color: #9ca3af; }
        .piece-black { background-color: #1f2937; color: #fff; border-color: #4b5563; }
        .piece-king { animation: pulse-slow 1s infinite alternate; }
        .piece-king-white { background: linear-gradient(145deg, #fef3c7, #fde047); }
        .piece-king-black { background: linear-gradient(145deg, #4b5563, #374151); color: #fde047; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-dark': '#1e293b',
                        'accent': '#ec4899',
                    },
                    keyframes: {
                        'pulse-slow': {
                            '0%, 100%': { opacity: 1, transform: 'scale(1)' },
                            '50%': { opacity: 0.9, transform: 'scale(1.05)' },
                        }
                    },
                    animation: {
                        'pulse-slow': 'pulse-slow 2s ease-in-out infinite',
                    }
                }
            }
        }
    </script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, collection, runTransaction, serverTimestamp, setLogLevel, getDoc, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        setLogLevel('Debug'); // Konsolda loglarƒ± g√∂rm…ôk √º√ß√ºn

        // Global D…ôyi≈ü…ônl…ôr
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-dama-app';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let unsubscribeRoom = null;
        let unsubscribeQueue = null;

        // UI Elementl…ôri
        const loader = document.getElementById('loader');
        const lobbyScreen = document.getElementById('lobby-screen');
        const gameScreen = document.getElementById('game-screen');
        const userNameDisplay = document.getElementById('user-name-display');
        const currentUserIdDisplay = document.getElementById('current-user-id-display');
        const connectionStatus = document.getElementById('connection-status');
        const dereceliBtn = document.getElementById('dereceli-btn');
        const deregeliCancelBtn = document.getElementById('deregeli-cancel-btn');
        const lobiStatusMessage = document.getElementById('lobi-status-message');
        const createRoomBtn = document.getElementById('create-room-btn');
        const roomCodeOutput = document.getElementById('room-code-output');
        const copyCodeBtn = document.getElementById('copy-code-btn');
        const joinRoomInput = document.getElementById('join-room-input');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const boardElement = document.getElementById('board');
        const currentTurnDisplay = document.getElementById('current-turn-display');
        const whiteTimerDisplay = document.getElementById('white-timer');
        const blackTimerDisplay = document.getElementById('black-timer');
        const leaveGameBtn = document.getElementById('leave-game-btn');
        const messageModal = document.getElementById('message-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // Game State
        let currentUserId = null;
        let currentUserName = null;
        let currentRoomId = null;
        let selectedPiece = null;
        let mandatoryCapture = null;
        let isMyTurn = false;
        let isInitialized = false;
        let timerInterval = null;
        let isSearchingRanked = false;

        // Sabitl…ôr
        const ROOMS_COLLECTION = `artifacts/${appId}/public/data/dama_rooms`;
        const QUEUE_COLLECTION = `artifacts/${appId}/public/data/dama_queue`;
        const BOARD_SIZE = 8;
        const TIMER_DURATION = 120; // 2 d…ôqiq…ô

        // --- Yardƒ±m√ßƒ± Funksiyalar ---

        function getTelegramUser() {
            const urlParams = new URLSearchParams(window.location.search);
            const tgUserId = urlParams.get('tg_user_id') || urlParams.get('id');
            const tgUsername = urlParams.get('tg_username') || urlParams.get('name');

            if (tgUserId) {
                return {
                    id: tgUserId,
                    name: tgUsername ? decodeURIComponent(tgUsername) : 'Telegram ƒ∞stifad…ô√ßisi',
                };
            }
            return null;
        }

        function showModal(message) {
            modalMessage.textContent = message;
            messageModal.classList.remove('hidden');
        }

        modalCloseBtn.onclick = () => {
            messageModal.classList.add('hidden');
        };

        function showScreen(screen) {
            loader.classList.add('hidden');
            lobbyScreen.classList.add('hidden');
            gameScreen.classList.add('hidden');
            deregeliCancelBtn.classList.add('hidden');

            if (screen === 'lobby') {
                lobbyScreen.classList.remove('hidden');
                lobiStatusMessage.textContent = 'Oyun rejimi se√ßin.';
                isSearchingRanked = false;
            } else if (screen === 'game') {
                gameScreen.classList.remove('hidden');
            } else if (screen === 'searching') {
                lobbyScreen.classList.remove('hidden');
                deregeliCancelBtn.classList.remove('hidden');
                lobiStatusMessage.textContent = 'R…ôqib axtarƒ±lƒ±r... L√ºtf…ôn g√∂zl…ôyin.';
                isSearchingRanked = true;
            } else {
                loader.classList.remove('hidden');
            }
        }

        function createInitialBoard() {
            const board = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                board[r] = new Array(BOARD_SIZE).fill(0);
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if ((r + c) % 2 !== 0) {
                        if (r < 3) {
                            board[r][c] = 1; // Aƒü da≈ü
                        } else if (r > 4) {
                            board[r][c] = 2; // Qara da≈ü
                        }
                    }
                }
            }
            return board;
        }

        function generateRoomCode() {
            // 4 r…ôq…ômli kod
            return String(Math.floor(1000 + Math.random() * 9000));
        }

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = seconds % 60;
            return `${min}:${sec.toString().padStart(2, '0')}`;
        }

        // --- Dama M…ôntiqi (∆èvv…ôlki koddan saxlanƒ±ldƒ±) ---

        function isValidCell(r, c) { return r >= 0 && r < BOARD_SIZE && c < BOARD_SIZE; }
        function getPiecePlayer(pieceValue) {
            if (pieceValue === 1 || pieceValue === 3) return 'white';
            if (pieceValue === 2 || pieceValue === 4) return 'black';
            return null;
        }
        function isKing(r, player) {
            return (player === 'white' && r === BOARD_SIZE - 1) || (player === 'black' && r === 0);
        }

        // Yem…ô h…ôr…ôk…ôtl…ôrini tapmaq
        function findJumps(board, r, c, player) {
            // ... (∆èvv…ôlki koddan findJumps m…ôntiqi)
            const piece = board[r][c];
            const isKingPiece = piece === 3 || piece === 4;
            const jumps = [];
            const directions = isKingPiece ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                player === 'white' ? [[1, -1], [1, 1]] : [[-1, -1], [-1, 1]];

            for (const [dr, dc] of directions) {
                const capturedR = r + dr;
                const capturedC = c + dc;
                const landR = r + 2 * dr;
                const landC = c + 2 * dc;

                if (isValidCell(landR, landC) && board[landR][landC] === 0) {
                    const capturedPieceValue = board[capturedR][capturedC];
                    const capturedPlayer = getPiecePlayer(capturedPieceValue);

                    if (capturedPlayer && capturedPlayer !== player) {
                        jumps.push({ from: { r, c }, to: { r: landR, c: landC }, captured: { r: capturedR, c: capturedC } });
                    }
                }
            }
            return jumps;
        }

        function findAllMandatoryJumps(board, player) {
            // ... (∆èvv…ôlki koddan findAllMandatoryJumps m…ôntiqi)
            let allJumps = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (getPiecePlayer(board[r][c]) === player) {
                        allJumps = allJumps.concat(findJumps(board, r, c, player));
                    }
                }
            }
            return allJumps;
        }

        function findLongestJumpChain(board, r, c, player, currentChain = [], maxChain = []) {
             // ... (∆èvv…ôlki koddan findLongestJumpChain m…ôntiqi)
            const possibleNextJumps = findJumps(board, r, c, player);

            if (possibleNextJumps.length === 0) {
                if (currentChain.length > maxChain.length) {
                    return currentChain;
                }
                return maxChain;
            }

            let bestChain = maxChain;

            for (const jump of possibleNextJumps) {
                const nextBoard = JSON.parse(JSON.stringify(board));
                nextBoard[r][c] = 0;
                nextBoard[jump.to.r][jump.to.c] = board[r][c];
                nextBoard[jump.captured.r][jump.captured.c] = 0;

                const newChain = [...currentChain, jump];
                const finalChain = findLongestJumpChain(
                    nextBoard,
                    jump.to.r,
                    jump.to.c,
                    player,
                    newChain,
                    bestChain
                );

                if (finalChain.length > bestChain.length) {
                    bestChain = finalChain;
                }
            }
            return bestChain;
        }

        function getMaxJumpChainLength(board, player) {
             // ... (∆èvv…ôlki koddan getMaxJumpChainLength m…ôntiqi)
            let maxLength = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (getPiecePlayer(board[r][c]) === player) {
                        const chain = findLongestJumpChain(board, r, c, player);
                        if (chain.length > maxLength) {
                            maxLength = chain.length;
                        }
                    }
                }
            }
            return maxLength;
        }

        function isValidMove(board, fromR, fromC, toR, toC, player) {
             // ... (∆èvv…ôlki koddan isValidMove m…ôntiqi)
            const piece = board[fromR][fromC];
            const isKingPiece = piece === 3 || piece === 4;
            const dr = toR - fromR;
            const dc = toC - fromC;
            const absDr = Math.abs(dr);
            const absDc = Math.abs(dc);

            const maxLength = getMaxJumpChainLength(board, player);

            // M…ôcburi yem…ô varsa
            if (maxLength > 0) {
                const isJumpMove = absDr === 2 && absDc === 2;
                if (!isJumpMove) return false;

                const currentPieceChain = findLongestJumpChain(board, fromR, fromC, player);
                if (currentPieceChain.length < maxLength) return false;

                const jumpsFromPiece = findJumps(board, fromR, fromC, player);
                const isPossibleJump = jumpsFromPiece.some(j => j.to.r === toR && j.to.c === toC);

                if (!isPossibleJump) return false;
            }

            // Adi h…ôr…ôk…ôt
            if (absDr === 1 && absDc === 1) {
                if (maxLength > 0) return false;

                if (isKingPiece) {
                    return true;
                } else if (player === 'white' && dr === 1) {
                    return true;
                } else if (player === 'black' && dr === -1) {
                    return true;
                }
            }

            // Yem…ô h…ôr…ôk…ôti (2 addƒ±m)
            if (absDr === 2 && absDc === 2) {
                const capturedR = (fromR + toR) / 2;
                const capturedC = (fromC + toC) / 2;
                const capturedPieceValue = board[capturedR][capturedC];
                const capturedPlayer = getPiecePlayer(capturedPieceValue);

                if (capturedPlayer && capturedPlayer !== player) {
                    return true;
                }
            }

            return false;
        }

        // --- Firebase/Oyun ƒ∞dar…ôetm…ôsi ---

        async function makeMove(fromR, fromC, toR, toC, currentBoard, player) {
            // ... (∆èvv…ôlki koddan makeMove m…ôntiqi)
            const roomRef = doc(db, ROOMS_COLLECTION, currentRoomId);
            const opponentColor = player === 'black' ? 'white' : 'black';
            const isJump = Math.abs(fromR - toR) === 2;

            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    const data = roomDoc.data();

                    if (data.turn !== player || data.status !== 'playing') {
                        throw new Error("G√∂zl…ôyin, n√∂vb…ô sizin deyil v…ô ya oyun bitib.");
                    }

                    let newBoard = JSON.parse(JSON.stringify(currentBoard));
                    let nextTurn = opponentColor;
                    let nextMandatoryCapture = null;

                    const pieceValue = newBoard[fromR][fromC];
                    newBoard[fromR][fromC] = 0;
                    newBoard[toR][toC] = pieceValue;

                    if (isJump) {
                        const capturedR = (fromR + toR) / 2;
                        const capturedC = (fromC + toC) / 2;
                        newBoard[capturedR][capturedC] = 0;

                        const subsequentJumps = findJumps(newBoard, toR, toC, player);
                        if (subsequentJumps.length > 0) {
                            nextTurn = player;
                            nextMandatoryCapture = { r: toR, c: toC };
                        }
                    }

                    if (isKing(toR, player) && !isKing(fromR, player)) {
                        newBoard[toR][toC] = player === 'white' ? 3 : 4;
                        nextTurn = opponentColor;
                        nextMandatoryCapture = null;
                    }

                    const whitePieces = newBoard.flat().filter(p => getPiecePlayer(p) === 'white').length;
                    const blackPieces = newBoard.flat().filter(p => getPiecePlayer(p) === 'black').length;

                    let winner = null;
                    if (whitePieces === 0) winner = 'Qara';
                    if (blackPieces === 0) winner = 'Aƒü';

                    if (winner) {
                         transaction.update(roomRef, {
                            board: newBoard,
                            status: 'finished',
                            winner: winner,
                            reason: `B√ºt√ºn ${winner === 'Aƒü' ? 'Qara' : 'Aƒü'} da≈ülar yeyildi.`,
                        });
                        return;
                    }

                    const newTimers = data.timers;
                    if (nextTurn !== player) {
                        newTimers[player] = data.timers[player];
                        newTimers[opponentColor] = TIMER_DURATION;
                    }

                    transaction.update(roomRef, {
                        board: newBoard,
                        turn: nextTurn,
                        timers: newTimers,
                        mandatoryCapture: nextMandatoryCapture,
                        lastMoveTimestamp: serverTimestamp(),
                    });
                });
            } catch (error) {
                console.error("H…ôr…ôk…ôt etm…ô x…ôtasƒ±:", error);
                showModal(`H…ôr…ôk…ôt etm…ôk m√ºmk√ºn olmadƒ±: ${error.message}`);
            }
        }

        // --- Lobiya Funksionallƒ±ƒüƒ± ---

        // 1. Dereceli E≈ül…ô≈üm…ô
        dereceliBtn.onclick = async () => {
            if (!currentUserId) return showModal("Z…ôhm…ôt olmasa, sistem…ô daxil olun.");
            showScreen('searching');

            try {
                // 1. G√∂zl…ôy…ôn r…ôqib axtar
                const q = query(collection(db, ROOMS_COLLECTION), where("status", "==", "waiting_for_ranked_opponent"));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    // R…ôqib tapƒ±ldƒ±! ƒ∞lk otaƒüa qo≈üul
                    const roomDoc = querySnapshot.docs[0];
                    const roomId = roomDoc.id;

                    await joinRoom(roomId, true);
                } else {
                    // R…ôqib yoxdur, g√∂zl…ôm…ô otaƒüƒ± yarat
                    const roomCode = generateRoomCode(); // Room ID √º√ß√ºn yeni kod istifad…ô et
                    currentRoomId = roomCode;

                    await setDoc(doc(db, ROOMS_COLLECTION, roomCode), {
                        roomId: roomCode,
                        status: 'waiting_for_ranked_opponent',
                        creator: { id: currentUserId, name: currentUserName },
                        opponent: null,
                        playerBlackId: currentUserId,
                        playerWhiteId: null,
                        lastMoveTimestamp: serverTimestamp(),
                    });
                    
                    // Yaradƒ±lmƒ±≈ü otaƒüa real-time dinl…ôyici …ôlav…ô et
                    listenToRoom(roomCode);
                }
            } catch (error) {
                console.error("Dereceli e≈ül…ô≈üm…ô x…ôtasƒ±:", error);
                showModal(`E≈ül…ô≈üm…ô x…ôtasƒ±: ${error.message}`);
                showScreen('lobby');
            }
        };

        deregeliCancelBtn.onclick = async () => {
            if (!currentRoomId || !isSearchingRanked) return;

            try {
                // Otaƒüƒ± silm…ôkl…ô n√∂vb…ôd…ôn √ßƒ±x
                await deleteDoc(doc(db, ROOMS_COLLECTION, currentRoomId));
                showModal("E≈ül…ô≈üm…ô axtarƒ±≈üƒ± l…ôƒüv edildi.");
            } catch (error) {
                console.error("L…ôƒüvetm…ô x…ôtasƒ±:", error);
                showModal("L…ôƒüv etm…ôk m√ºmk√ºn olmadƒ±, lakin lobiya yenil…ôn…ôc…ôk.");
            } finally {
                if (unsubscribeRoom) unsubscribeRoom();
                currentRoomId = null;
                showScreen('lobby');
            }
        };

        // 2. Dostla Oyna (Otaq Yarat)
        createRoomBtn.onclick = async () => {
            if (!currentUserId) return showModal("Sistem…ô giri≈ü edilm…ôyib.");
            showScreen('loading');

            const roomCode = generateRoomCode();
            const roomRef = doc(db, ROOMS_COLLECTION, roomCode);

            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (roomDoc.exists()) throw new Error("Otaq kodu artƒ±q m√∂vcuddur. Yenid…ôn c…ôhd edin.");

                    const initialBoard = createInitialBoard();

                    transaction.set(roomRef, {
                        roomId: roomCode,
                        status: 'waiting_for_friend',
                        creator: { id: currentUserId, name: currentUserName },
                        opponent: null,
                        board: initialBoard,
                        turn: 'black',
                        playerBlackId: currentUserId,
                        playerWhiteId: null,
                        lastMoveTimestamp: serverTimestamp(),
                        timers: { white: TIMER_DURATION, black: TIMER_DURATION },
                        mandatoryCapture: null,
                    });
                });
                currentRoomId = roomCode;
                roomCodeOutput.textContent = roomCode;
                lobiStatusMessage.textContent = `Otaq yaratƒ±ldƒ±: ${roomCode}. R…ôqib g√∂zl…ônilir...`;
                listenToRoom(roomCode);
                // Lobiya ekranƒ±na qayƒ±dƒ±rƒ±q, lakin status mesajƒ± il…ô
                showScreen('lobby');
            } catch (error) {
                console.error("Otaq yaratmaq x…ôtasƒ±:", error);
                showModal(`Otaq yaratmaq m√ºmk√ºn olmadƒ±: ${error.message}`);
                showScreen('lobby');
            }
        };

        // Kodu Kopyala
        copyCodeBtn.onclick = () => {
            const code = roomCodeOutput.textContent;
            if (code && code !== '...') {
                try {
                    // Deprecated olsa da, iFrame √º√ß√ºn …ôn etibarlƒ± kopyalama metodu
                    const tempInput = document.createElement('input');
                    document.body.appendChild(tempInput);
                    tempInput.value = code;
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                    showModal(`Otaq kodu (${code}) kopyalandƒ±!`);
                } catch (err) {
                    showModal("Kopyalama x…ôtasƒ±: L√ºtf…ôn kodu …ôl il…ô kopyalayƒ±n.");
                }
            }
        };

        // 3. Koda Qo≈üul
        joinRoomBtn.onclick = () => {
            const roomCode = joinRoomInput.value.trim();
            if (roomCode.length !== 4) return showModal("Xahi≈ü edirik, 4 r…ôq…ômli otaq kodunu daxil edin.");
            if (!currentUserId) return showModal("Sistem…ô giri≈ü edilm…ôyib.");

            joinRoom(roomCode, false);
        };

        async function joinRoom(roomId, isRanked) {
            if (unsubscribeRoom) unsubscribeRoom();

            const roomRef = doc(db, ROOMS_COLLECTION, roomId);
            currentRoomId = roomId;

            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);

                    if (!roomDoc.exists()) {
                        currentRoomId = null;
                        throw new Error("Bel…ô bir otaq kodu tapƒ±lmadƒ±.");
                    }

                    const roomData = roomDoc.data();

                    const isWaiting = roomData.status === 'waiting_for_friend' || roomData.status === 'waiting_for_ranked_opponent';
                    const isMyRoom = roomData.playerBlackId === currentUserId || roomData.playerWhiteId === currentUserId;

                    if (!isWaiting && !isMyRoom) {
                        currentRoomId = null;
                        throw new Error("Otaq doludur v…ô ya oyun gedir.");
                    }

                    if (isWaiting && roomData.playerBlackId !== currentUserId) {
                        // R…ôqib kimi qo≈üulur
                        transaction.update(roomRef, {
                            opponent: { id: currentUserId, name: currentUserName },
                            status: 'playing',
                            playerWhiteId: currentUserId,
                            timers: { white: TIMER_DURATION, black: TIMER_DURATION }
                        });
                    }
                    // ∆èg…ôr otaq yaradƒ±cƒ±sƒ±dƒ±rsa (isMyRoom) sad…ôc…ô yenid…ôn qo≈üulur (reload)

                });

                listenToRoom(roomId);
            } catch (error) {
                console.error("Otaƒüa qo≈üulmaq x…ôtasƒ±:", error);
                showModal(error.message);
                showScreen('lobby');
            }
        }

        // Oyunu t…ôrk etm…ôk
        leaveGameBtn.onclick = () => leaveGame();

        async function leaveGame() {
            if (!currentRoomId || !currentUserId) return;
            showScreen('loading');

            if (unsubscribeRoom) {
                unsubscribeRoom();
                unsubscribeRoom = null;
            }
            clearInterval(timerInterval);
            timerInterval = null;

            const roomRef = doc(db, ROOMS_COLLECTION, currentRoomId);

            try {
                 await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) return;

                    const roomData = roomDoc.data();
                    const myColor = (roomData.playerBlackId === currentUserId) ? 'Qara' : 'Aƒü';
                    const opponentColor = myColor === 'Qara' ? 'Aƒü' : 'Qara';

                    if (roomData.status.startsWith('waiting')) {
                        // G√∂zl…ôy…ôn otaqdƒ±rsa, sil
                        transaction.delete(roomRef);
                    } else if (roomData.status === 'playing') {
                        // ∆èg…ôr m…ôn √ßƒ±xƒ±ramsa, dig…ôr oyun√ßu qalib g…ôlir
                        const winnerName = (opponentColor === 'Qara') ? roomData.creator?.name || 'Qara Oyun√ßu' : roomData.opponent?.name || 'Aƒü Oyun√ßu';

                        transaction.update(roomRef, {
                            status: 'finished',
                            winner: winnerName,
                            reason: `${currentUserName} (${myColor}) oyunu t…ôrk etdi. ${opponentColor} qalib g…ôldi.`,
                        });
                    }
                });
            } catch (error) {
                console.error("Oyundan √ßƒ±xma x…ôtasƒ±:", error);
            } finally {
                currentRoomId = null;
                selectedPiece = null;
                showScreen('lobby');
            }
        }

        // Otaqdakƒ± d…ôyi≈üiklikl…ôri dinl…ôm…ôk (onSnapshot)
        function listenToRoom(roomId) {
            if (unsubscribeRoom) unsubscribeRoom();

            const roomRef = doc(db, ROOMS_COLLECTION, roomId);
            roomCodeOutput.textContent = roomId;
            joinRoomInput.value = ''; // Otaq kodu daxil etm…ô yerini t…ômizl…ô

            unsubscribeRoom = onSnapshot(roomRef, (docSnap) => {
                if (!docSnap.exists()) {
                    if (currentRoomId === roomId) { // Yalnƒ±z cari otaq silinibs…ô
                        showModal("R…ôqib oyunu t…ôrk etdi v…ô ya otaq silindi. Lobyey…ô qayƒ±dƒ±rsƒ±nƒ±z.");
                        currentRoomId = null;
                        clearInterval(timerInterval);
                        timerInterval = null;
                        showScreen('lobby');
                    }
                    return;
                }

                const data = docSnap.data();

                if (data.status === 'finished') {
                    const winnerMessage = data.reason ? data.reason : `Oyun Bitdi! Qalib: ${data.winner}`;
                    showModal(winnerMessage);
                    // Qalibiyy…ôt mesajƒ±ndan sonra avtomatik lobiy…ô qayƒ±t
                    if (currentRoomId === roomId) leaveGame();
                    return;
                }

                if (data.status.startsWith('waiting')) {
                    const waitingMessage = data.status === 'waiting_for_ranked_opponent' ? 'R…ôqib axtarƒ±lƒ±r...' : `Otaq kodu: ${roomId}. R…ôqib g√∂zl…ônilir...`;
                    lobiStatusMessage.textContent = waitingMessage;
                    showScreen(data.status === 'waiting_for_ranked_opponent' ? 'searching' : 'lobby');
                    return;
                }

                // Oyun oynanƒ±lƒ±r (status: 'playing')
                if (data.playerBlackId === currentUserId || data.playerWhiteId === currentUserId) {
                    showScreen('game');
                    updateGameUI(data);
                    if (!timerInterval) {
                        startTimerLoop(data.roomId);
                    }
                }
            }, (error) => {
                console.error("Firestore dinl…ôm…ô x…ôtasƒ±:", error);
                showModal("Serverl…ô …ôlaq…ô k…ôsildi. Yenid…ôn c…ôhd edin.");
                if (unsubscribeRoom) unsubscribeRoom();
                currentRoomId = null;
                showScreen('lobby');
            });
        }

        // UI-ƒ± yenil…ôm…ôk
        function updateGameUI(data) {
            const myColor = data.playerBlackId === currentUserId ? 'black' : 'white';
            const myTurn = data.turn === myColor;
            isMyTurn = myTurn;

            currentTurnDisplay.textContent = myTurn ? 'Sizin N√∂vb…ônizdir' : `R…ôqibd…ôdir (${data.turn === 'black' ? 'Qara' : 'Aƒü'})`;
            currentTurnDisplay.className = `text-lg font-bold p-2 rounded-lg ${myTurn ? 'bg-green-600' : 'bg-yellow-600'} text-white shadow-lg transition duration-300`;

            drawBoard(data.board, data.turn, data.mandatoryCapture);

            whiteTimerDisplay.textContent = formatTime(data.timers.white);
            blackTimerDisplay.textContent = formatTime(data.timers.black);

            const whiteTimerClass = data.turn === 'white' ? 'bg-red-500 animate-flicker' : 'bg-gray-700';
            const blackTimerClass = data.turn === 'black' ? 'bg-red-500 animate-flicker' : 'bg-gray-700';

            whiteTimerDisplay.className = `p-2 rounded-lg font-mono text-xl text-white shadow-md ${whiteTimerClass}`;
            blackTimerDisplay.className = `p-2 rounded-lg font-mono text-xl text-white shadow-md ${blackTimerClass}`;
        }

        // Boardu √ß…ôkm…ôk v…ô interaktiv etm…ôk
        function drawBoard(board, turnColor, mandatoryCaptureCoords) {
            boardElement.innerHTML = '';
            mandatoryCapture = mandatoryCaptureCoords;
            const myColor = getPiecePlayer(board.flat().find(p => p !== 0 && (getPiecePlayer(p) === 'black' && p === 2 || p === 4) || (getPiecePlayer(p) === 'white' && p === 1 || p === 3))); // H…ôr hansƒ± bir da≈üdan r…ôngi tapmaq
            const isMyTurnColor = turnColor === myColor;

            const maxLength = getMaxJumpChainLength(board, turnColor);
            const piecesToGlow = new Set();

            if (maxLength > 0) {
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (getPiecePlayer(board[r][c]) === turnColor) {
                            const chain = findLongestJumpChain(board, r, c, turnColor);
                            if (chain.length === maxLength) {
                                piecesToGlow.add(`${r},${c}`);
                            }
                        }
                    }
                }
            }


            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    const isDark = (r + c) % 2 !== 0;

                    cell.className = `cell ${isDark ? 'bg-pink-300' : 'bg-pink-100'} transition duration-150 ease-in-out`;
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.onclick = () => handleCellClick(r, c, board, turnColor);

                    const pieceValue = board[r][c];
                    if (pieceValue !== 0) {
                        const pieceElement = document.createElement('div');
                        const piecePlayer = getPiecePlayer(pieceValue);
                        const isKingPiece = pieceValue === 3 || pieceValue === 4;

                        pieceElement.className = `piece flex items-center justify-center ${
                            piecePlayer === 'white' ? 'piece-white' : 'piece-black'
                        } ${isKingPiece ? (piecePlayer === 'white' ? 'piece-king piece-king-white' : 'piece-king piece-king-black') : ''}`;

                        pieceElement.innerHTML = isKingPiece ? 'üëë' : '‚óè';

                        // M…ôcburi yem…ô animasiyasƒ±
                        const shouldGlow = piecesToGlow.has(`${r},${c}`) && isMyTurnColor;
                        if (shouldGlow) {
                            pieceElement.classList.add('animate-pulse-fast', 'ring-4', 'ring-offset-2', 'ring-red-600', 'shadow-2xl');
                            pieceElement.title = "M…ôcburi yem…ô!";
                        }

                        // Se√ßilmi≈ü da≈ü
                        if (selectedPiece && selectedPiece.r === r && selectedPiece.c === c) {
                            pieceElement.classList.add('ring-4', 'ring-blue-500', 'ring-offset-2');
                            cell.classList.add('bg-blue-300');
                        }

                        cell.appendChild(pieceElement);
                    }

                    // Vurma h…ôd…ôfi vurƒüulanmasƒ±
                    if (selectedPiece && board[r][c] === 0) {
                        if (isValidMove(board, selectedPiece.r, selectedPiece.c, r, c, turnColor)) {
                            cell.classList.add('bg-green-400', 'cursor-pointer', 'ring-2', 'ring-green-700');
                            cell.title = 'M√ºmk√ºn H…ôr…ôk…ôt';
                        }
                    }

                    boardElement.appendChild(cell);
                }
            }
        }

        // Xana klikl…ôm…ô hadis…ôsi
        async function handleCellClick(r, c, board, turnColor) {
            const myColor = turnColor; // Kimin n√∂vb…ôsidirs…ô, o da≈üƒ± idar…ô edir.
            const piecePlayer = getPiecePlayer(board[r][c]);

            if (turnColor !== (board.flat().find(p => getPiecePlayer(p) === 'black' ? p === 2 || p === 4 : p === 1 || p === 3) ? (board.flat().find(p => getPiecePlayer(p) === 'black' ? p === 2 || p === 4 : p === 1 || p === 3) % 2 === 0 ? 'black' : 'white') : null)) return showModal("N√∂vb…ô sizin deyil.");
            
            if (currentRoomId) {
                const roomDoc = await getDoc(doc(db, ROOMS_COLLECTION, currentRoomId));
                if (!roomDoc.exists() || roomDoc.data().turn !== myColor) return showModal("N√∂vb…ô sizin deyil.");
            }


            // 1. Da≈ü se√ßimi
            if (piecePlayer === myColor) {
                const maxLength = getMaxJumpChainLength(board, myColor);
                if (maxLength > 0) {
                    const currentPieceChain = findLongestJumpChain(board, r, c, myColor);
                    if (currentPieceChain.length < maxLength) {
                        return showModal("∆èn uzun yem…ô z…ôncirin…ô aid olan da≈üƒ± se√ßm…ôlisiniz!");
                    }
                }

                selectedPiece = { r, c };
                drawBoard(board, myColor, mandatoryCapture);
            }
            // 2. H…ôr…ôk…ôt etm…ôk
            else if (selectedPiece && piecePlayer === null) {
                const fromR = selectedPiece.r;
                const fromC = selectedPiece.c;

                if (isValidMove(board, fromR, fromC, r, c, myColor)) {
                    await makeMove(fromR, fromC, r, c, board, myColor);
                } else {
                    showModal("Qeyri-qanuni h…ôr…ôk…ôt.");
                }
                selectedPiece = null;
            }
        }

        async function handleTimeout(roomId, timedOutPlayer, board) {
            // ... (∆èvv…ôlki koddan handleTimeout m…ôntiqi)
            const roomRef = doc(db, ROOMS_COLLECTION, roomId);
            const timedOutColor = timedOutPlayer;
            const winningColor = timedOutPlayer === 'black' ? 'Aƒü' : 'Qara';

            try {
                 await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists() || roomDoc.data().status !== 'playing' || roomDoc.data().turn !== timedOutPlayer) {
                        return;
                    }

                    const data = roomDoc.data();
                    const allJumps = findAllMandatoryJumps(board, timedOutColor);

                    if (allJumps.length > 0) {
                        const maxLength = getMaxJumpChainLength(board, timedOutColor);
                        const possibleMoves = [];

                        for (let r = 0; r < BOARD_SIZE; r++) {
                            for (let c = 0; c < BOARD_SIZE; c++) {
                                if (getPiecePlayer(board[r][c]) === timedOutColor) {
                                    const chain = findLongestJumpChain(board, r, c, timedOutColor);
                                    if (chain.length === maxLength) {
                                        const jumps = findJumps(board, r, c, timedOutColor);
                                        jumps.forEach(jump => possibleMoves.push(jump));
                                    }
                                }
                            }
                        }

                        if (possibleMoves.length > 0) {
                            const randomJump = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                            const { from, to, captured } = randomJump;

                            let newBoard = JSON.parse(JSON.stringify(board));
                            newBoard[from.r][from.c] = 0;
                            newBoard[to.r][to.c] = board[from.r][from.c];
                            newBoard[captured.r][captured.c] = 0;

                            let nextTurn = timedOutPlayer === 'black' ? 'white' : 'black';
                            let nextMandatoryCapture = null;
                            const subsequentJumps = findJumps(newBoard, to.r, to.c, timedOutColor);

                             if (subsequentJumps.length > 0) {
                                nextTurn = timedOutPlayer;
                                nextMandatoryCapture = { r: to.r, c: to.c };
                            }

                            transaction.update(roomRef, {
                                board: newBoard,
                                turn: nextTurn,
                                timers: { ...data.timers, [timedOutPlayer]: TIMER_DURATION },
                                mandatoryCapture: nextMandatoryCapture,
                                lastMoveTimestamp: serverTimestamp(),
                            });
                            showModal(`${timedOutColor} oyun√ßunun vaxtƒ± bitdi. M…ôcburi yem…ô avtomatik edildi.`);
                            return;
                        }
                    }

                    const reason = `${timedOutColor} oyun√ßunun vaxtƒ± bitdi. Oyunu ${winningColor} qazandƒ±.`;
                    transaction.update(roomRef, {
                        status: 'finished',
                        winner: winningColor,
                        reason: reason,
                    });

                });
            } catch (error) {
                console.error("Timeout x…ôtasƒ±:", error);
            }
        }

        // Timer Loopunu Ba≈ülatmaq
        function startTimerLoop(roomId) {
            clearInterval(timerInterval);

            timerInterval = setInterval(async () => {
                if (!currentRoomId || !isInitialized) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    return;
                }

                const roomRef = doc(db, ROOMS_COLLECTION, roomId);

                try {
                    await runTransaction(db, async (transaction) => {
                        const roomDoc = await transaction.get(roomRef);
                        if (!roomDoc.exists() || roomDoc.data().status !== 'playing') {
                             clearInterval(timerInterval);
                             timerInterval = null;
                             return;
                        }

                        const data = roomDoc.data();
                        const turn = data.turn;
                        const lastMove = data.lastMoveTimestamp.toDate().getTime();
                        const now = Date.now();
                        const elapsedSeconds = Math.floor((now - lastMove) / 1000);

                        let currentTimer = data.timers[turn] - elapsedSeconds;

                        if (currentTimer <= 0) {
                            currentTimer = 0;
                            transaction.update(roomRef, {
                                timers: { ...data.timers, [turn]: 0 }
                            });
                            handleTimeout(roomId, turn, data.board);
                            clearInterval(timerInterval);
                            timerInterval = null;
                        } else {
                            transaction.update(roomRef, {
                                timers: { ...data.timers, [turn]: currentTimer }
                            });
                        }
                    });
                } catch (error) {
                    // Transaction x…ôtalarƒ± normaldƒ±r
                }
            }, 1000);
        }

        // --- Ba≈ülanƒüƒ±c v…ô Autentifikasiya ---

        async function initApp() {
            if (!firebaseConfig) {
                showModal("Firebase konfigurasiyasƒ± tapƒ±lmadƒ±.");
                return;
            }

            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            connectionStatus.textContent = 'Server…ô qo≈üulur...';
            connectionStatus.classList.remove('text-red-500');
            connectionStatus.classList.add('text-yellow-400', 'animate-pulse');

            const telegramUser = getTelegramUser();
            let authCompleted = false;

            onAuthStateChanged(auth, async (user) => {
                if (user && !authCompleted) {
                    authCompleted = true;

                    currentUserId = user.uid;
                    currentUserName = telegramUser ? telegramUser.name : `Anonim-${user.uid.substring(0, 4)}`;

                    userNameDisplay.textContent = currentUserName;
                    currentUserIdDisplay.textContent = currentUserId;

                    connectionStatus.textContent = 'Server…ô qo≈üuldu!';
                    connectionStatus.classList.remove('text-yellow-400', 'animate-pulse');
                    connectionStatus.classList.add('text-green-500');

                    showScreen('lobby');
                    isInitialized = true;

                } else if (!user && !authCompleted) {
                    if (initialAuthToken) {
                         try {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } catch (error) {
                            await signInAnonymously(auth);
                        }
                    } else {
                        await signInAnonymously(auth);
                    }
                }
            });

             if (initialAuthToken) {
                 try {
                     await signInWithCustomToken(auth, initialAuthToken);
                 } catch (error) {
                     await signInAnonymously(auth);
                 }
             } else {
                 await signInAnonymously(auth);
             }

            window.addEventListener('beforeunload', () => {
                if (currentRoomId && !unsubscribeRoom) {
                    // Bu, h…ôr…ôk…ôt zamanƒ± i≈ül…ôm…ôy…ô bil…ôr, amma r…ôqib…ô x…ôb…ôr verm…ôk √º√ß√ºn Firestorda silinir.
                }
            });
        }

        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</head>

<body class="bg-primary-dark text-slate-200 min-h-screen p-4 flex flex-col items-center justify-center font-inter">

    <!-- Modal Mesaj Qutusu (Global) -->
    <div id="message-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-white text-gray-800 p-6 rounded-xl shadow-2xl max-w-sm w-full transform transition duration-300 scale-100">
            <h3 class="text-xl font-bold mb-4 text-accent">Bildiri≈ü</h3>
            <p id="modal-message" class="mb-6"></p>
            <button id="modal-close-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 button-glow">
                Baƒüla
            </button>
        </div>
    </div>

    <!-- Ba≈ülƒ±q v…ô Status -->
    <div class="mb-8 p-4 rounded-xl bg-slate-800 shadow-2xl title-glow">
        <h1 class="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-pink-400 to-red-500">
            AZ∆èRBAYCAN DAMASI
        </h1>
        <p id="connection-status" class="text-sm text-center mt-1 text-yellow-400 font-semibold transition duration-300">Y√ºkl…ônir...</p>
    </div>

    <!-- ƒ∞stifad…ô√ßi M…ôlumatƒ± Paneli -->
    <div class="w-full max-w-4xl mb-6 bg-slate-800 p-4 rounded-xl shadow-lg flex flex-col sm:flex-row justify-between items-center space-y-2 sm:space-y-0">
        <p class="text-sm font-medium">Oyun√ßu: <span id="user-name-display" class="font-bold text-green-400">Y√ºkl…ônir...</span></p>
        <p class="text-xs text-slate-400">ID: <span id="current-user-id-display">Y√ºkl…ônir...</span></p>
    </div>

    <!-- Loading (Y√ºkl…ônir) Ekranƒ± -->
    <div id="loader" class="text-center p-8 bg-slate-800 rounded-xl shadow-lg">
        <div class="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-pink-500 mx-auto mb-4"></div>
        <p class="text-lg">Sistem…ô Giri≈ü Edilir...</p>
    </div>

    <!-- Lobiya Ekranƒ± -->
    <div id="lobby-screen" class="hidden w-full max-w-lg bg-slate-800 p-8 rounded-2xl shadow-3xl border border-slate-700">
        <h2 class="text-3xl font-bold text-center mb-6 text-accent animate-flicker">Oyun Lobisi</h2>
        <p id="lobi-status-message" class="text-center text-yellow-300 mb-6 font-semibold transition duration-300">Oyun rejimi se√ßin.</p>

        <div class="space-y-6">
            <!-- 1. Dereceli E≈ül…ô≈üm…ô -->
            <button id="dereceli-btn" class="w-full bg-pink-600 hover:bg-pink-700 text-white font-extrabold py-4 px-4 rounded-xl transition duration-300 transform hover:scale-[1.02] shadow-xl button-glow">
                Dereceli Ba≈ülat (Avto E≈ül…ô≈üm…ô)
            </button>
            <button id="deregeli-cancel-btn" class="hidden w-full bg-red-600 hover:bg-red-700 text-white font-extrabold py-4 px-4 rounded-xl transition duration-300 transform hover:scale-[1.02] shadow-xl">
                E≈ül…ô≈üm…ôni L…ôƒüv Et
            </button>

            <!-- 2. Arkada≈üla Oyna (Otaq Yarat) -->
            <div class="bg-slate-700 p-5 rounded-xl shadow-inner space-y-3">
                <h3 class="text-xl font-bold text-blue-400">Arkada≈üla Oyna</h3>
                <button id="create-room-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg transition duration-150 button-glow">
                    Yeni Otaq Yarat
                </button>
                <div class="flex items-center space-x-2 pt-2">
                    <span class="text-sm font-semibold text-slate-300">Otaq Kodu:</span>
                    <span id="room-code-output" class="text-2xl font-mono text-green-400 bg-slate-900 px-3 py-1 rounded-md shadow-inner select-all">...</span>
                    <button id="copy-code-btn" class="bg-gray-500 hover:bg-gray-600 text-white text-xs py-1 px-3 rounded-md transition duration-150">
                        Kopyala
                    </button>
                </div>
            </div>

            <!-- 3. Koda Qo≈üul -->
            <div class="flex space-x-2 bg-slate-700 p-5 rounded-xl shadow-inner">
                <input id="join-room-input" type="number" placeholder="Otaq Kodunu Daxil Edin (4 R…ôq…ôm)" class="flex-grow p-3 rounded-lg border-2 border-slate-600 bg-slate-900 text-white placeholder-slate-400 focus:ring-accent focus:border-accent" maxlength="4">
                <button id="join-room-btn" class="bg-accent hover:bg-pink-600 text-white font-bold py-3 px-6 rounded-lg transition duration-150 transform hover:scale-[1.02] shadow-md button-glow">
                    Qo≈üul
                </button>
            </div>
        </div>
    </div>

    <!-- Oyun Ekranƒ± -->
    <div id="game-screen" class="hidden w-full max-w-4xl flex flex-col items-center">

        <div class="flex justify-between w-full max-w-md mb-4 bg-slate-800 p-3 rounded-xl shadow-lg">
             <!-- Qara Oyun√ßunun Timeri (Siz) -->
            <div class="flex flex-col items-center space-y-1">
                <p class="text-sm font-semibold text-white">Qara:</p>
                <div id="black-timer" class="p-2 rounded-lg font-mono text-xl text-white bg-gray-700 shadow-md">0:00</div>
            </div>

            <!-- N√∂vb…ô Statusu (M…ôrk…ôz) -->
            <div id="current-turn-display" class="text-lg font-bold p-2 rounded-lg bg-yellow-600 text-white shadow-lg self-center">
                N√∂vb…ô Y√ºkl…ônir...
            </div>

            <!-- Aƒü Oyun√ßunun Timeri (R…ôqib) -->
            <div class="flex flex-col items-center space-y-1">
                <p class="text-sm font-semibold text-white">Aƒü:</p>
                <div id="white-timer" class="p-2 rounded-lg font-mono text-xl text-white bg-gray-700 shadow-md">0:00</div>
            </div>
        </div>

        <!-- Dama Taxtasƒ± -->
        <div id="board" class="board mb-8">
            <!-- Da≈ülar burada JavaScript il…ô √ß…ôkilir -->
        </div>

        <button id="leave-game-btn" class="mt-4 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-xl transition duration-150 transform hover:scale-[1.05] shadow-xl">
            Oyundan √áƒ±x
        </button>

    </div>

</body>
</html>
