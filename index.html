<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matter.js Sword Ball Duel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* General Style and Mobile Responsiveness */
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            margin: 0;
            background-color: #2c3e50;
            color: #ecf0f1;
            flex-direction: column;
            overflow: hidden;
            padding: 5px; 
            box-sizing: border-box;
        }

        /* Main Game Container and Responsive Square Rule */
        #game-container {
            position: relative;
            width: 90vmin; /* 90% of the smaller dimension (maintains square) */
            height: 90vmin;
            max-width: 800px; 
            max-height: 800px;
            border: 10px solid #3498db;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #3b5971;
            overflow: hidden;
            margin: 10px;
            flex-shrink: 0;
        }

        /* Ball Photo Divs */
        .ball-photo-div {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            transition: transform 0.05s ease-out;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 5;
        }
        
        /* SWORD VISUAL IMPROVEMENT (Circular Sword Emojis) */
        .sword-icon-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150%; 
            height: 150%;
            display: none;
            pointer-events: none; 
            z-index: 10;
        }

        .sword-icon {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-50%); 
            font-size: 30px;
            text-shadow: 0 0 8px #f1c40f, 0 0 5px #e67e22;
            animation: sword-spin 1s linear infinite; 
            transform-origin: 50% 150%; 
        }

        /* Three Swords around the ball */
        .sword-icon-container .sword-1 { transform: rotate(0deg) translate(0, -60px); }
        .sword-icon-container .sword-2 { transform: rotate(120deg) translate(0, -60px); }
        .sword-icon-container .sword-3 { transform: rotate(240deg) translate(0, -60px); }
        
        /* Base Spin Animation */
        @keyframes sword-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Hit Effect */
        .hit-effect {
            animation: hit-shake 0.3s ease-in-out;
            box-shadow: 0 0 20px 5px #e74c3c;
        }

        @keyframes hit-shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            20% { transform: translate(-3px, 0px) rotate(-2deg); }
            40% { transform: translate(3px, 1px) rotate(2deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            80% { transform: translate(1px, -1px) rotate(2deg); }
            100% { transform: translate(1px, 1px) rotate(0deg); }
        }

        /* Item Icon */
        #item-emoji {
            position: absolute;
            font-size: 40px;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 10;
        }

        /* Info Panel (Health & Controls) */
        .info-panel {
            width: 90vmin;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-status {
            padding: 5px 10px;
            width: 30%;
            font-size: 14px;
            text-align: center;
        }
        
        /* HEART HEALTH BAR */
        .health-display {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            height: 30px;
        }
        
        .heart {
            font-size: 20px;
            margin: 0 2px;
            transition: opacity 0.3s;
        }
        
        .heart.lost {
            opacity: 0.3;
        }

        #customize-button {
            padding: 8px 15px;
            font-size: 14px;
            background-color: #f39c12;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        #customize-button:hover {
            background-color: #e67e22;
        }

        /* Modals and other UI */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #3b5971;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
        }

        /* ... (Rest of the modal styles from previous version, adapted for English) ... */
        .player-setup {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }

        .player-setup > div {
            width: 45%;
        }

        input[type="text"], button, .file-upload-label {
            margin: 5px 0;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
            border-radius: 5px;
            border: none;
        }

        .file-upload-label {
            display: inline-block;
            background-color: #2ecc71;
            color: white;
            cursor: pointer;
            text-align: center;
        }
        
        .file-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #555;
            margin: 10px auto;
            background-size: cover;
            background-position: center;
        }

        #start-custom-game-button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        /* Matter.js Canvas hiding (Only CSS Divs are visible) */
        #game-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; 
            display: none !important;
        }
    </style>
</head>
<body>

    <div class="info-panel">
        <div id="p1-health-status" class="player-status">
            <h3 id="p1-name-display">Player 1 Health: 5/5</h3>
            <div id="p1-health" class="health-display">
                </div>
        </div>
        <button id="customize-button">New Game / Customize</button>
        <div id="p2-health-status" class="player-status">
            <h3 id="p2-name-display">Player 2 Health: 5/5</h3>
            <div id="p2-health" class="health-display">
                </div>
        </div>
    </div>

    <div id="game-container">
        <div id="ball1-photo" class="ball-photo-div" style="background-color: #FF5252;">
            üî¥
            <div id="p1-sword-container" class="sword-icon-container">
                 <span class="sword-icon sword-1">‚öîÔ∏è</span>
                 <span class="sword-icon sword-2">‚öîÔ∏è</span>
                 <span class="sword-icon sword-3">‚öîÔ∏è</span>
            </div>
        </div>
        <div id="ball2-photo" class="ball-photo-div" style="background-color: #2196F3;">
            üîµ
            <div id="p2-sword-container" class="sword-icon-container">
                <span class="sword-icon sword-1">‚öîÔ∏è</span>
                <span class="sword-icon sword-2">‚öîÔ∏è</span>
                <span class="sword-icon sword-3">‚öîÔ∏è</span>
            </div>
        </div>
        <div id="item-emoji">‚öîÔ∏è</div>
    </div>

    <div id="setup-modal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h2>Customize Game</h2>
            <div class="player-setup">
                <div>
                    <h3>Player 1 (üî¥)</h3>
                    <input type="text" id="p1-name-input" placeholder="Enter Name (e.g., Captain)">
                    <input type="file" id="p1-file" accept="image/*" style="display: none;">
                    <label for="p1-file" class="file-upload-label">Upload Photo</label>
                    <div id="p1-preview" class="file-preview"></div>
                </div>
                <div>
                    <h3>Player 2 (üîµ)</h3>
                    <input type="text" id="p2-name-input" placeholder="Enter Name (e.g., Iron Man)">
                    <input type="file" id="p2-file" accept="image/*" style="display: none;">
                    <label for="p2-file" class="file-upload-label">Upload Photo</label>
                    <div id="p2-preview" class="file-preview"></div>
                </div>
            </div>
            <button id="start-custom-game-button" disabled>Start Game</button>
        </div>
    </div>

    <div id="game-over-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2 id="winner-text"></h2>
            <div id="winner-emoji"></div>
            <button id="restart-button">Play Again (Same Settings)</button>
            <button id="new-game-button">Start New Game</button>
        </div>
    </div>

    <script>
        // Matter.js Modules
        const { Engine, Render, Runner, Bodies, Composite, Events, Body, Vector } = Matter;

        // --- GLOBAL CONSTANTS (SPEED ADJUSTMENT) ---
        const MAX_HEALTH = 5;
        const BASE_SPEED = 5; // Game speed reduced from 8 to 5
        const KICK_MULTIPLIER = 2.5; // Kicked ball acceleration multiplier (increased slightly)
        const ITEM_RESPAWN_TIME = 3000;
        let INITIAL_BALL_RADIUS = 40; 
        let arenaWidth = 800;
        let arenaHeight = 800;

        // --- GLOBAL VARIABLES ---
        let engine, render, runner, world;
        let ball1, ball2;
        let currentItem = null;
        let itemSpawnTimer = null;
        let isGameOver = true;
        
        // --- SOUND FILES (FROM GITHUB) ---
        const knifeSounds = [
            'YOUR_GITHUB_PATH/knife1.mp3', // **L√úTFEN KENDƒ∞ YOLUNUZLA DEƒûƒ∞≈ûTƒ∞Rƒ∞N**
            'YOUR_GITHUB_PATH/knife2.mp3', // **L√úTFEN KENDƒ∞ YOLUNUZLA DEƒûƒ∞≈ûTƒ∞Rƒ∞N**
            'YOUR_GITHUB_PATH/knife3.mp3'  // **L√úTFEN KENDƒ∞ YOLUNUZLA DEƒûƒ∞≈ûTƒ∞Rƒ∞N**
        ];
        // √ñrnek: 'https://raw.githubusercontent.com/username/repo/main/knife1.mp3'

        // HTML Elements and Player Info
        const gameContainer = document.getElementById('game-container');
        const photo1Div = document.getElementById('ball1-photo');
        const photo2Div = document.getElementById('ball2-photo');
        const itemEmojiDiv = document.getElementById('item-emoji');
        const p1NameDisplay = document.getElementById('p1-name-display');
        const p2NameDisplay = document.getElementById('p2-name-display');
        const setupModal = document.getElementById('setup-modal');
        const gameOverModal = document.getElementById('game-over-modal');
        const winnerText = document.getElementById('winner-text');
        const winnerEmoji = document.getElementById('winner-emoji');
        const customizeButton = document.getElementById('customize-button');
        const startGameCustomButton = document.getElementById('start-custom-game-button');
        const p1NameInput = document.getElementById('p1-name-input');
        const p2NameInput = document.getElementById('p2-name-input');
        
        // New Health Bar Elements
        const p1HealthDisplay = document.getElementById('p1-health');
        const p2HealthDisplay = document.getElementById('p2-health');

        const playerInfo = {
            ball1: {
                id: 'ball1',
                name: 'Player 1',
                health: MAX_HEALTH,
                hasSword: false,
                texture: '',
                emoji: 'üî¥',
                color: '#FF5252',
                photoDiv: photo1Div,
                nameDisplay: p1NameDisplay,
                healthDisplay: p1HealthDisplay,
                swordContainer: document.getElementById('p1-sword-container')
            },
            ball2: {
                id: 'ball2',
                name: 'Player 2',
                health: MAX_HEALTH,
                hasSword: false,
                texture: '',
                emoji: 'üîµ',
                color: '#2196F3',
                photoDiv: photo2Div,
                nameDisplay: p2NameDisplay,
                healthDisplay: p2HealthDisplay,
                swordContainer: document.getElementById('p2-sword-container')
            }
        };

        // --- SOUND FUNCTION ---
        function playRandomKnifeSound() {
            const randomIndex = Math.floor(Math.random() * knifeSounds.length);
            const audio = new Audio(knifeSounds[randomIndex]);
            audio.volume = 0.5;
            audio.play().catch(e => console.error("Sound playback failed:", e));
        }


        // --- HEART HEALTH RENDER FUNCTION ---
        function renderHearts(player) {
            player.healthDisplay.innerHTML = ''; // Clear existing hearts
            for (let i = 0; i < MAX_HEALTH; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                heart.textContent = '‚ù§Ô∏è';
                if (i >= player.health) {
                    heart.classList.add('lost');
                }
                player.healthDisplay.appendChild(heart);
            }
            player.nameDisplay.textContent = `${player.name} Health: ${player.health}/${MAX_HEALTH}`;
        }
        
        function updateHealthBar(p1, p1Health, p2, p2Health) {
            p1.health = p1Health;
            p2.health = p2Health;
            renderHearts(p1);
            renderHearts(p2);

            if (p1Health <= 0) endGame(p2);
            if (p2Health <= 0) endGame(p1);
        }

        // --- RESPONSIVE AND ARENA MANAGEMENT ---
        function updateArenaSize() {
            const container = gameContainer;
            const size = Math.min(container.clientWidth, container.clientHeight);
            
            arenaWidth = size;
            arenaHeight = size;
            INITIAL_BALL_RADIUS = size * 0.05; // 5% radius
            
            if (render) {
                render.canvas.width = arenaWidth;
                render.canvas.height = arenaHeight;
                render.options.width = arenaWidth;
                render.options.height = arenaHeight;
                Render.setPixelRatio(render, window.devicePixelRatio);
            }

            const ballDiameter = INITIAL_BALL_RADIUS * 2;
            photo1Div.style.width = `${ballDiameter}px`;
            photo1Div.style.height = `${ballDiameter}px`;
            photo2Div.style.width = `${ballDiameter}px`;
            photo2Div.style.height = `${ballDiameter}px`;
            
            if (ball1 && ball2) {
                Body.set(ball1, 'circleRadius', INITIAL_BALL_RADIUS);
                Body.set(ball2, 'circleRadius', INITIAL_BALL_RADIUS);
            }

            if (world) setupWalls();
        }

        function setupWalls() {
            if (!world) return;
            Composite.allBodies(world).forEach(body => {
                if (body.label === 'wall' || body.label === 'sword') {
                     Composite.remove(world, body);
                }
            });

            const wallThickness = 20;

            const walls = [
                Bodies.rectangle(arenaWidth / 2, wallThickness / 2, arenaWidth, wallThickness, { isStatic: true, label: 'wall', render: { fillStyle: '#333' } }),
                Bodies.rectangle(arenaWidth / 2, arenaHeight - wallThickness / 2, arenaWidth, wallThickness, { isStatic: true, label: 'wall', render: { fillStyle: '#333' } }),
                Bodies.rectangle(wallThickness / 2, arenaHeight / 2, wallThickness, arenaHeight, { isStatic: true, label: 'wall', render: { fillStyle: '#333' } }),
                Bodies.rectangle(arenaWidth - wallThickness / 2, arenaHeight / 2, wallThickness, arenaHeight, { isStatic: true, label: 'wall', render: { fillStyle: '#333' } })
            ];
            Composite.add(world, walls);
        }

        function initializeGame() {
            if (!engine) {
                engine = Engine.create();
                world = engine.world;
                world.gravity.y = 0;
                world.gravity.x = 0;
            } else {
                Engine.clear(engine);
                Composite.clear(world, false);
            }
            
            if (runner) Runner.stop(runner);
            runner = Runner.create();
            Runner.run(runner, engine);

            Events.off(engine, 'afterUpdate', afterUpdateHandler);
            Events.off(engine, 'collisionStart', collisionStartHandler);
            Events.on(engine, 'afterUpdate', afterUpdateHandler);
            Events.on(engine, 'collisionStart', collisionStartHandler);
            
            updateArenaSize();
            setupWalls();

            if (!render) {
                render = Render.create({
                    element: gameContainer,
                    engine: engine,
                    options: {
                        width: arenaWidth,
                        height: arenaHeight,
                        wireframes: false,
                        background: 'transparent',
                        showAngleIndicator: false
                    }
                });
                Render.run(render);
            }
            
            ball1 = null; ball2 = null;
            currentItem = null;
            clearTimeout(itemSpawnTimer);
            itemEmojiDiv.style.display = 'none';

            playerInfo.ball1.health = MAX_HEALTH;
            playerInfo.ball2.health = MAX_HEALTH;
            playerInfo.ball1.hasSword = false;
            playerInfo.ball2.hasSword = false;
            
            const ballOptions = {
                restitution: 1, 
                friction: 0, 
                frictionAir: 0, 
                density: 0.1, 
                inertia: Infinity,
                label: 'ball', 
                render: { fillStyle: 'transparent', strokeStyle: 'transparent' }
            };

            ball1 = Bodies.circle(arenaWidth / 3, arenaHeight / 2, INITIAL_BALL_RADIUS, { ...ballOptions, label: 'ball1', mass: 1, inverseMass: 1 });
            ball2 = Bodies.circle(arenaWidth * 2 / 3, arenaHeight / 2, INITIAL_BALL_RADIUS, { ...ballOptions, label: 'ball2', mass: 1, inverseMass: 1 });
            
            const speed = BASE_SPEED;
            const angle1 = Math.random() * Math.PI * 2; 
            const angle2 = Math.PI + Math.random() * Math.PI; 
            
            Body.setVelocity(ball1, { x: Math.cos(angle1) * speed, y: Math.sin(angle1) * speed });
            Body.setVelocity(ball2, { x: Math.cos(angle2) * speed, y: Math.sin(angle2) * speed });

            Composite.add(world, [ball1, ball2]);
            isGameOver = false;

            updateHealthBar(playerInfo.ball1, MAX_HEALTH, playerInfo.ball2, MAX_HEALTH);
            
            updateBallVisuals(playerInfo.ball1);
            updateBallVisuals(playerInfo.ball2);

            setTimeout(spawnItem, 1000);
        }

        // Fix: Ensure photo only shows, without underlying color
        function updateBallVisuals(player) {
            if (player.texture) {
                player.photoDiv.style.backgroundImage = `url(${player.texture})`;
                player.photoDiv.textContent = '';
                player.photoDiv.style.backgroundColor = 'transparent'; // FIX: Remove colored background
            } else {
                player.photoDiv.style.backgroundImage = 'none';
                player.photoDiv.style.backgroundColor = player.color;
                player.photoDiv.textContent = player.emoji;
            }
        }

        // Responsive handling
        const resizeObserver = new ResizeObserver(entries => {
            if (isGameOver) return;
            
            const oldArenaWidth = arenaWidth;
            const oldArenaHeight = arenaHeight;
            
            updateArenaSize();
            
            if (ball1 && ball2 && oldArenaWidth > 0 && oldArenaHeight > 0) {
                const scaleX = arenaWidth / oldArenaWidth;
                const scaleY = arenaHeight / oldArenaHeight;
                
                Body.setPosition(ball1, { x: ball1.position.x * scaleX, y: ball1.position.y * scaleY });
                Body.setPosition(ball2, { x: ball2.position.x * scaleX, y: ball2.position.y * scaleY });
            }
        });
        resizeObserver.observe(gameContainer);


        // --- GAME LOGIC FUNCTIONS ---
        function updatePhotoPosition(body, player) {
            if (body) {
                player.photoDiv.style.left = `${body.position.x - INITIAL_BALL_RADIUS}px`;
                player.photoDiv.style.top = `${body.position.y - INITIAL_BALL_RADIUS}px`;
                Body.setAngularVelocity(body, 0); 
                
                if (player.hasSword) {
                    player.swordContainer.style.display = 'block';
                } else {
                    player.swordContainer.style.display = 'none';
                }
            }
        }
        
        // Speed and Boundary Control (Updated)
        const afterUpdateHandler = function() {
            if (isGameOver || !ball1 || !ball2) return; 

            if (currentItem) {
                itemEmojiDiv.style.left = `${currentItem.position.x}px`;
                itemEmojiDiv.style.top = `${currentItem.position.y}px`;
            }

            updatePhotoPosition(ball1, playerInfo.ball1);
            updatePhotoPosition(ball2, playerInfo.ball2);

            const checkBallBoundsAndSpeed = (ball) => {
                const wallThickness = 20;
                const halfBall = INITIAL_BALL_RADIUS;
                let newX = ball.position.x;
                let newY = ball.position.y;
                let velocity = { ...ball.velocity };

                // Boundary Control
                const minX = wallThickness + halfBall;
                const maxX = arenaWidth - wallThickness - halfBall;
                const minY = wallThickness + halfBall;
                const maxY = arenaHeight - wallThickness - halfBall;

                if (newX < minX) { newX = minX; velocity.x = Math.abs(velocity.x); } 
                else if (newX > maxX) { newX = maxX; velocity.x = -Math.abs(velocity.x); }

                if (newY < minY) { newY = minY; velocity.y = Math.abs(velocity.y); } 
                else if (newY > maxY) { newY = maxY; velocity.y = -Math.abs(velocity.y); }
                
                if (newX !== ball.position.x || newY !== ball.position.y) {
                    Body.setPosition(ball, { x: newX, y: newY });
                }
                
                // SPEED CONTROL (Maintain speed around BASE_SPEED, or Kicked speed)
                const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
                const targetSpeed = Math.max(BASE_SPEED, currentSpeed); // Use current speed if higher than base (e.g., after a kick)
                
                if (currentSpeed !== 0 && currentSpeed !== BASE_SPEED) {
                    // Only damp or adjust if significantly higher than KICK_MULTIPLIER * BASE_SPEED 
                    // or if it dropped below BASE_SPEED.
                    const maxSpeedLimit = BASE_SPEED * KICK_MULTIPLIER * 1.5; 
                    if (currentSpeed > maxSpeedLimit || currentSpeed < BASE_SPEED * 0.9) {
                        const scaleFactor = BASE_SPEED / currentSpeed;
                        velocity.x *= scaleFactor;
                        velocity.y *= scaleFactor;
                    }
                }

                Body.setVelocity(ball, velocity);
                Body.setAngularVelocity(ball, 0); 
            };

            checkBallBoundsAndSpeed(ball1);
            checkBallBoundsAndSpeed(ball2);
        };
        
        // Collision Logic (Sword Damage and KICK)
        const collisionStartHandler = function(event) {
            if (isGameOver) return;

            const pairs = event.pairs;

            pairs.forEach(pair => {
                const labels = [pair.bodyA.label, pair.bodyB.label];
                const isItemCollision = labels.includes('sword');
                const isBallCollision = labels.includes('ball1') && labels.includes('ball2');

                // 1. Item Pickup
                if (isItemCollision && (labels.includes('ball1') || labels.includes('ball2'))) {
                    const takerBall = pair.bodyA.label.startsWith('ball') ? pair.bodyA : pair.bodyB;
                    
                    playerInfo.ball1.hasSword = (takerBall === ball1);
                    playerInfo.ball2.hasSword = (takerBall === ball2);
                    
                    Composite.remove(world, currentItem);
                    itemEmojiDiv.style.display = 'none';
                    currentItem = null;
                    itemSpawnTimer = setTimeout(spawnItem, ITEM_RESPAWN_TIME);
                }

                // 2. Ball Collision (Damage & Kick)
                if (isBallCollision) {
                    const p1 = playerInfo.ball1;
                    const p2 = playerInfo.ball2;

                    let damageDealt = false;
                    let damagedPlayer = null;
                    let damagedBall = null;
                    let attackingBall = null;

                    if (p1.hasSword && !p2.hasSword) {
                        p2.health--;
                        p1.hasSword = false;
                        damageDealt = true;
                        damagedPlayer = p2;
                        damagedBall = ball2;
                        attackingBall = ball1;
                    } else if (p2.hasSword && !p1.hasSword) {
                        p1.health--;
                        p2.hasSword = false;
                        damageDealt = true;
                        damagedPlayer = p1;
                        damagedBall = ball1;
                        attackingBall = ball2;
                    } else if (p1.hasSword && p2.hasSword) {
                        p1.hasSword = false;
                        p2.hasSword = false;
                    }
                    
                    if (damageDealt) {
                        playRandomKnifeSound(); 
                        
                        updateHealthBar(p1, p1.health, p2, p2.health);
                        
                        damagedPlayer.photoDiv.classList.add('hit-effect');
                        removeHitEffect(damagedPlayer);

                        // KICK EFFECT (Speed up the damaged ball)
                        const currentVelocity = damagedBall.velocity;
                        const currentSpeed = Vector.magnitude(currentVelocity);

                        if (currentSpeed > 0) {
                            const newSpeed = BASE_SPEED * KICK_MULTIPLIER;
                            const newVelocity = Vector.mult(Vector.normalise(currentVelocity), newSpeed);
                            Body.setVelocity(damagedBall, newVelocity);
                        }
                    }
                }
            });
        };

        function removeHitEffect(player) {
            setTimeout(() => {
                player.photoDiv.classList.remove('hit-effect');
            }, 300);
        }

        function spawnItem() {
            if (isGameOver) return;
            const size = 15;
            const x = Math.random() * (arenaWidth - 100) + 50;
            const y = Math.random() * (arenaHeight - 100) + 50;
            
            currentItem = Bodies.circle(x, y, size, { 
                isStatic: true, 
                isSensor: true, 
                label: 'sword', 
                render: { fillStyle: 'transparent' } 
            });
            Composite.add(world, currentItem);
            
            itemEmojiDiv.style.left = `${x}px`;
            itemEmojiDiv.style.top = `${y}px`;
            itemEmojiDiv.style.display = 'block';
        }

        function endGame(winner) {
            isGameOver = true;
            Runner.stop(runner);
            clearTimeout(itemSpawnTimer);

            winnerText.textContent = `${winner.name} Wins!`;
            winnerEmoji.textContent = winner.emoji;
            gameOverModal.style.display = 'flex';
        }


        // --- UI & CUSTOMIZATION LOGIC ---

        function handleFileChange(event, player) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    player.texture = e.target.result;
                    document.getElementById(`${player.id.replace('ball', 'p')}-preview`).style.backgroundImage = `url(${e.target.result})`;
                    checkSetupComplete();
                };
                reader.readAsDataURL(file);
            }
        }
        
        function checkSetupComplete() {
            const p1Name = p1NameInput.value.trim();
            const p2Name = p2NameInput.value.trim();
            
            if (p1Name && p2Name) {
                startGameCustomButton.disabled = false;
            } else {
                startGameCustomButton.disabled = true;
            }
        }

        function setupGameAndStart() {
            playerInfo.ball1.name = p1NameInput.value.trim() || 'Player 1';
            playerInfo.ball2.name = p2NameInput.value.trim() || 'Player 2';
            
            // Set visuals based on uploaded textures
            // Texture is already set in handleFileChange
            
            setupModal.style.display = 'none';
            initializeGame();
        }

        // --- EVENT LISTENERS ---
        p1NameInput.addEventListener('input', checkSetupComplete);
        p2NameInput.addEventListener('input', checkSetupComplete);
        document.getElementById('p1-file').addEventListener('change', (e) => handleFileChange(e, playerInfo.ball1));
        document.getElementById('p2-file').addEventListener('change', (e) => handleFileChange(e, playerInfo.ball2));
        startGameCustomButton.addEventListener('click', setupGameAndStart);
        customizeButton.addEventListener('click', () => setupModal.style.display = 'flex');
        document.getElementById('restart-button').addEventListener('click', () => {
            gameOverModal.style.display = 'none';
            initializeGame();
        });
        document.getElementById('new-game-button').addEventListener('click', () => {
            gameOverModal.style.display = 'none';
            setupModal.style.display = 'flex';
        });

        // Initial setup check
        checkSetupComplete(); 
    </script>
</body>
</html>
