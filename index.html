<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matter.js Sword Ball Duel - Pro Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* Base Styling */
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            color: #ecf0f1;
            flex-direction: column;
            overflow: hidden;
            padding: 5px; 
            box-sizing: border-box;
        }

        /* Game Arena (Responsive Square) */
        #game-container {
            position: relative;
            width: 90vmin; 
            height: 90vmin;
            max-width: 800px; 
            max-height: 800px;
            border: 10px solid #3498db;
            border-radius: 5px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
            background-color: #3b5971;
            overflow: hidden;
            margin: 10px;
            flex-shrink: 0;
        }

        /* Ball Visual Div (Handles both Color and Photo) */
        .ball-photo-div {
            position: absolute;
            /* Size controlled by JS (INITIAL_BALL_RADIUS * 2) */
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            transition: transform 0.05s ease-out;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 5;
            /* **FOTOƒûRAF BOYUTU FIX** */
            background-color: transparent; 
        }
        
        /* Inner circle for emoji when no photo is uploaded */
        .ball-emoji-display {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: inherit; /* Inherits initial color or stays transparent */
        }

        /* SWORD VISUALS */
        .sword-icon-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150%; 
            height: 150%;
            display: none;
            pointer-events: none; 
            z-index: 10;
            animation: sword-spin 1s linear infinite; /* Base Spin Animation */
        }

        .sword-icon {
            position: absolute;
            font-size: 30px;
            text-shadow: 0 0 0 #f1c40f, 0 0 5px #e67e22;
        }

        /* Positioning the three swords around the center */
        .sword-icon-container .sword-1 { transform: rotate(0deg) translate(0, -100%) rotate(0deg); }
        .sword-icon-container .sword-2 { transform: rotate(120deg) translate(0, -100%) rotate(-120deg); }
        .sword-icon-container .sword-3 { transform: rotate(240deg) translate(0, -100%) rotate(-240deg); }
        
        @keyframes sword-spin {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Hit Effect */
        .hit-effect {
            animation: hit-shake 0.3s ease-in-out;
            box-shadow: 0 0 20px 5px #e74c3c;
        }

        @keyframes hit-shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            20% { transform: translate(-3px, 0px) rotate(-2deg); }
            40% { transform: translate(3px, 1px) rotate(2deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            80% { transform: translate(1px, -1px) rotate(2deg); }
            100% { transform: translate(1px, 1px) rotate(0deg); }
        }

        /* Item Icon (Sword Drop) */
        #item-emoji {
            position: absolute;
            font-size: 40px;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 10;
        }

        /* Info Panel (Health & Controls) */
        .info-panel {
            width: 90vmin;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-status {
            padding: 5px 10px;
            width: 30%;
            font-size: 14px;
            text-align: center;
            background-color: #1a2533;
            border-radius: 5px;
        }
        
        /* HEART HEALTH DISPLAY */
        .health-display {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            height: 30px;
        }
        
        .heart {
            font-size: 20px;
            margin: 0 2px;
            color: #e74c3c; /* Full heart color */
            transition: opacity 0.3s;
        }
        
        .heart.lost {
            color: #95a5a6; /* Lost heart color */
        }

        #customize-button {
            padding: 8px 15px;
            font-size: 14px;
            background-color: #f39c12;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        #customize-button:hover {
            background-color: #e67e22;
        }

        /* Modals and other UI (Pro Look) */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #2c3e50;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(52, 152, 219, 0.5);
            border: 1px solid #3498db;
        }

        input[type="text"], button, .file-upload-label {
            margin: 8px 0;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
            border-radius: 5px;
            border: 1px solid #95a5a6;
            background-color: #ecf0f1;
            color: #2c3e50;
        }

        .file-upload-label {
            display: inline-block;
            background-color: #2ecc71;
            color: white;
            cursor: pointer;
            text-align: center;
            border: none;
        }
        
        .file-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #555;
            margin: 10px auto;
            background-size: cover;
            background-position: center;
            border: 2px solid #fff;
        }

        #start-custom-game-button {
            background-color: #3498db;
            color: white;
            font-weight: bold;
            margin-top: 15px;
        }

        #start-custom-game-button:disabled {
            background-color: #5d7c99;
            cursor: not-allowed;
        }
        
        /* Matter.js Canvas hiding */
        #game-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; 
            display: none !important;
        }
    </style>
</head>
<body>

    <div class="info-panel">
        <div id="p1-health-status" class="player-status">
            <h3 id="p1-name-display">Player 1 Health: 5/5</h3>
            <div id="p1-health" class="health-display"></div>
        </div>
        <button id="customize-button">New Game / Customize</button>
        <div id="p2-health-status" class="player-status">
            <h3 id="p2-name-display">Player 2 Health: 5/5</h3>
            <div id="p2-health" class="health-display"></div>
        </div>
    </div>

    <div id="game-container">
        <div id="ball1-photo" class="ball-photo-div">
            <div id="ball1-emoji" class="ball-emoji-display" style="background-color: #FF5252;">üî¥</div>
            <div id="p1-sword-container" class="sword-icon-container">
                 <span class="sword-icon sword-1">‚öîÔ∏è</span>
                 <span class="sword-icon sword-2">‚öîÔ∏è</span>
                 <span class="sword-icon sword-3">‚öîÔ∏è</span>
            </div>
        </div>
        
        <div id="ball2-photo" class="ball-photo-div">
            <div id="ball2-emoji" class="ball-emoji-display" style="background-color: #2196F3;">üîµ</div>
            <div id="p2-sword-container" class="sword-icon-container">
                <span class="sword-icon sword-1">‚öîÔ∏è</span>
                <span class="sword-icon sword-2">‚öîÔ∏è</span>
                <span class="sword-icon sword-3">‚öîÔ∏è</span>
            </div>
        </div>
        <div id="item-emoji">‚öîÔ∏è</div>
    </div>

    <div id="setup-modal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h2>Customize Game</h2>
            <div class="player-setup">
                <div>
                    <h3>Player 1 (üî¥)</h3>
                    <input type="text" id="p1-name-input" placeholder="Enter Name (e.g., Captain)">
                    <input type="file" id="p1-file" accept="image/*" style="display: none;">
                    <label for="p1-file" class="file-upload-label">Upload Photo</label>
                    <div id="p1-preview" class="file-preview"></div>
                </div>
                <div>
                    <h3>Player 2 (üîµ)</h3>
                    <input type="text" id="p2-name-input" placeholder="Enter Name (e.g., Iron Man)">
                    <input type="file" id="p2-file" accept="image/*" style="display: none;">
                    <label for="p2-file" class="file-upload-label">Upload Photo</label>
                    <div id="p2-preview" class="file-preview"></div>
                </div>
            </div>
            <button id="start-custom-game-button" disabled>Start Game</button>
        </div>
    </div>

    <div id="game-over-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2 id="winner-text"></h2>
            <div id="winner-emoji"></div>
            <button id="restart-button">Play Again (Same Settings)</button>
            <button id="new-game-button">Start New Game</button>
        </div>
    </div>

    <script>
        // Matter.js Modules
        const { Engine, Render, Runner, Bodies, Composite, Events, Body, Vector } = Matter;

        // --- GLOBAL CONSTANTS ---
        const MAX_HEALTH = 5;
        const BASE_SPEED = 4; // Reduced speed to 4
        const KICK_DURATION = 500; // 0.5 seconds in milliseconds
        const KICK_SPEED = 10; // Kicked speed
        const ITEM_RESPAWN_TIME = 3000;
        let INITIAL_BALL_RADIUS = 40; 
        let arenaWidth = 800;
        let arenaHeight = 800;

        // --- GLOBAL VARIABLES ---
        let engine, runner, world, render;
        let ball1, ball2;
        let currentItem = null;
        let itemSpawnTimer = null;
        let isGameOver = true;
        
        // KICK TIMERS
        let kickTimer1 = null;
        let kickTimer2 = null;

        // --- SOUND FILES (Local path assumption) ---
        const knifeSounds = [
            'knife1.mp3', 
            'knife2.mp3', 
            'knife3.mp3'
        ];

        // HTML Elements and Player Info
        const gameContainer = document.getElementById('game-container');
        const p1NameDisplay = document.getElementById('p1-name-display');
        const p2NameDisplay = document.getElementById('p2-name-display');
        const itemEmojiDiv = document.getElementById('item-emoji');
        const p1HealthDisplay = document.getElementById('p1-health');
        const p2HealthDisplay = document.getElementById('p2-health');
        
        // Player Info Object
        const playerInfo = {
            ball1: {
                id: 'ball1',
                name: 'Player 1',
                health: MAX_HEALTH,
                hasSword: false,
                texture: null,
                emoji: 'üî¥',
                color: '#FF5252',
                photoDiv: document.getElementById('ball1-photo'),
                emojiDiv: document.getElementById('ball1-emoji'),
                nameDisplay: p1NameDisplay,
                healthDisplay: p1HealthDisplay,
                swordContainer: document.getElementById('p1-sword-container')
            },
            ball2: {
                id: 'ball2',
                name: 'Player 2',
                health: MAX_HEALTH,
                hasSword: false,
                texture: null,
                emoji: 'üîµ',
                color: '#2196F3',
                photoDiv: document.getElementById('ball2-photo'),
                emojiDiv: document.getElementById('ball2-emoji'),
                nameDisplay: p2NameDisplay,
                healthDisplay: p2HealthDisplay,
                swordContainer: document.getElementById('p2-sword-container')
            }
        };

        // --- SOUND FUNCTION ---
        function playRandomKnifeSound() {
            const randomIndex = Math.floor(Math.random() * knifeSounds.length);
            const audio = new Audio(knifeSounds[randomIndex]);
            audio.volume = 0.5;
            audio.play().catch(e => console.error("Sound playback failed (Check file path):", e));
        }

        // --- HEALTH AND VISUALS ---

        function renderHearts(player) {
            player.healthDisplay.innerHTML = '';
            for (let i = 0; i < MAX_HEALTH; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                heart.textContent = '‚ù§Ô∏è';
                if (i >= player.health) {
                    heart.classList.add('lost');
                }
                player.healthDisplay.appendChild(heart);
            }
            player.nameDisplay.textContent = `${player.name} Health: ${player.health}/${MAX_HEALTH}`;
        }
        
        function updateHealthBar(p1, p1Health, p2, p2Health) {
            p1.health = p1Health;
            p2.health = p2Health;
            renderHearts(p1);
            renderHearts(p2);

            if (p1Health <= 0) endGame(p2);
            if (p2Health <= 0) endGame(p1);
        }

        // FIX: Photo size matching ball size and hiding color top
        function updateBallVisuals(player) {
            const ballDiameter = INITIAL_BALL_RADIUS * 2;
            player.photoDiv.style.width = `${ballDiameter}px`;
            player.photoDiv.style.height = `${ballDiameter}px`;
            
            if (player.texture) {
                // If texture exists, apply it to the main div and hide the inner emoji div
                player.photoDiv.style.backgroundImage = `url(${player.texture})`;
                player.emojiDiv.style.display = 'none';
            } else {
                // If no texture, hide background image and show the colored emoji div
                player.photoDiv.style.backgroundImage = 'none';
                player.emojiDiv.style.display = 'flex';
                player.emojiDiv.style.backgroundColor = player.color;
            }
        }

        // --- ARENA AND INITIALIZATION ---

        function updateArenaSize() {
            // ... (Same updateArenaSize logic) ...
            const container = gameContainer;
            const size = Math.min(container.clientWidth, container.clientHeight);
            
            arenaWidth = size;
            arenaHeight = size;
            INITIAL_BALL_RADIUS = size * 0.05; 
            
            if (render) {
                render.canvas.width = arenaWidth;
                render.canvas.height = arenaHeight;
                render.options.width = arenaWidth;
                render.options.height = arenaHeight;
                Render.setPixelRatio(render, window.devicePixelRatio);
            }

            updateBallVisuals(playerInfo.ball1);
            updateBallVisuals(playerInfo.ball2);
            
            if (ball1 && ball2) {
                Body.set(ball1, 'circleRadius', INITIAL_BALL_RADIUS);
                Body.set(ball2, 'circleRadius', INITIAL_BALL_RADIUS);
            }

            if (world) setupWalls();
        }

        function setupWalls() {
            // ... (Same setupWalls logic) ...
            if (!world) return;
            Composite.allBodies(world).forEach(body => {
                if (body.label === 'wall' || body.label === 'sword') {
                     Composite.remove(world, body);
                }
            });

            const wallThickness = 20;

            const walls = [
                Bodies.rectangle(arenaWidth / 2, wallThickness / 2, arenaWidth, wallThickness, { isStatic: true, label: 'wall', render: { fillStyle: '#333' } }),
                Bodies.rectangle(arenaWidth / 2, arenaHeight - wallThickness / 2, arenaWidth, wallThickness, { isStatic: true, label: 'wall', render: { fillStyle: '#333' } }),
                Bodies.rectangle(wallThickness / 2, arenaHeight / 2, wallThickness, arenaHeight, { isStatic: true, label: 'wall', render: { fillStyle: '#333' } }),
                Bodies.rectangle(arenaWidth - wallThickness / 2, arenaHeight / 2, wallThickness, arenaHeight, { isStatic: true, label: 'wall', render: { fillStyle: '#333' } })
            ];
            Composite.add(world, walls);
        }

        function initializeGame() {
            // ... (Same initialization logic) ...
             if (!engine) {
                engine = Engine.create();
                world = engine.world;
                world.gravity.y = 0;
                world.gravity.x = 0;
            } else {
                Engine.clear(engine);
                Composite.clear(world, false);
            }
            
            if (runner) Runner.stop(runner);
            runner = Runner.create();
            Runner.run(runner, engine);

            Events.off(engine, 'afterUpdate', afterUpdateHandler);
            Events.off(engine, 'collisionStart', collisionStartHandler);
            Events.on(engine, 'afterUpdate', afterUpdateHandler);
            Events.on(engine, 'collisionStart', collisionStartHandler);
            
            updateArenaSize();
            setupWalls();

            if (!render) {
                render = Render.create({
                    element: gameContainer,
                    engine: engine,
                    options: {
                        width: arenaWidth,
                        height: arenaHeight,
                        wireframes: false,
                        background: 'transparent',
                        showAngleIndicator: false
                    }
                });
                Render.run(render);
            }
            
            ball1 = null; ball2 = null;
            currentItem = null;
            clearTimeout(itemSpawnTimer);
            itemEmojiDiv.style.display = 'none';

            playerInfo.ball1.health = MAX_HEALTH;
            playerInfo.ball2.health = MAX_HEALTH;
            playerInfo.ball1.hasSword = false;
            playerInfo.ball2.hasSword = false;
            
            const ballOptions = {
                restitution: 1, 
                friction: 0, 
                frictionAir: 0, 
                density: 0.1, 
                inertia: Infinity,
                label: 'ball', 
                render: { fillStyle: 'transparent', strokeStyle: 'transparent' }
            };

            ball1 = Bodies.circle(arenaWidth / 3, arenaHeight / 2, INITIAL_BALL_RADIUS, { ...ballOptions, label: 'ball1', mass: 1, inverseMass: 1 });
            ball2 = Bodies.circle(arenaWidth * 2 / 3, arenaHeight / 2, INITIAL_BALL_RADIUS, { ...ballOptions, label: 'ball2', mass: 1, inverseMass: 1 });
            
            const speed = BASE_SPEED;
            const angle1 = Math.random() * Math.PI * 2; 
            const angle2 = Math.PI + Math.random() * Math.PI; 
            
            Body.setVelocity(ball1, { x: Math.cos(angle1) * speed, y: Math.sin(angle1) * speed });
            Body.setVelocity(ball2, { x: Math.cos(angle2) * speed, y: Math.sin(angle2) * speed });

            Composite.add(world, [ball1, ball2]);
            isGameOver = false;

            updateHealthBar(playerInfo.ball1, MAX_HEALTH, playerInfo.ball2, MAX_HEALTH);
            
            updateBallVisuals(playerInfo.ball1);
            updateBallVisuals(playerInfo.ball2);

            setTimeout(spawnItem, 1000);
        }

        // --- GAME LOOP & KICK MANAGEMENT ---

        function applyKick(ball, duration) {
            const currentVelocity = ball.velocity;
            const currentSpeed = Vector.magnitude(currentVelocity);

            // Apply kick speed
            if (currentSpeed > 0) {
                const newVelocity = Vector.mult(Vector.normalise(currentVelocity), KICK_SPEED);
                Body.setVelocity(ball, newVelocity);
            }
            
            // Set timer to reset speed after duration
            const player = (ball === ball1) ? playerInfo.ball1 : playerInfo.ball2;
            if (player.id === 'ball1') {
                clearTimeout(kickTimer1);
                kickTimer1 = setTimeout(() => {
                    resetSpeed(ball);
                }, duration);
            } else {
                clearTimeout(kickTimer2);
                kickTimer2 = setTimeout(() => {
                    resetSpeed(ball);
                }, duration);
            }
        }
        
        function resetSpeed(ball) {
             const currentVelocity = ball.velocity;
             const currentSpeed = Vector.magnitude(currentVelocity);
             
             if (currentSpeed > BASE_SPEED) {
                const newVelocity = Vector.mult(Vector.normalise(currentVelocity), BASE_SPEED);
                Body.setVelocity(ball, newVelocity);
             }
        }

        // Game Loop Update
        const afterUpdateHandler = function() {
            if (isGameOver || !ball1 || !ball2) return; 

            if (currentItem) {
                itemEmojiDiv.style.left = `${currentItem.position.x}px`;
                itemEmojiDiv.style.top = `${currentItem.position.y}px`;
            }

            // Update photo positions
            const updateBallDisplay = (ball, player) => {
                if (ball) {
                    player.photoDiv.style.left = `${ball.position.x - INITIAL_BALL_RADIUS}px`;
                    player.photoDiv.style.top = `${ball.position.y - INITIAL_BALL_RADIUS}px`;
                    player.swordContainer.style.display = player.hasSword ? 'block' : 'none';
                    Body.setAngularVelocity(ball, 0); 
                }
            };

            updateBallDisplay(ball1, playerInfo.ball1);
            updateBallDisplay(ball2, playerInfo.ball2);

            // Apply Speed Dampening (To return to BASE_SPEED after kick/impact)
            const checkSpeed = (ball) => {
                const currentVelocity = ball.velocity;
                const currentSpeed = Vector.magnitude(currentVelocity);
                
                // If speed is much higher than BASE_SPEED and the kick timer is finished, reduce it.
                const player = (ball === ball1) ? playerInfo.ball1 : playerInfo.ball2;
                const isKicked = (player.id === 'ball1' && kickTimer1 !== null) || (player.id === 'ball2' && kickTimer2 !== null);
                
                if (!isKicked && currentSpeed > BASE_SPEED * 1.1) {
                    // Gradual dampening back to BASE_SPEED
                    const dampeningFactor = (BASE_SPEED * 1.05) / currentSpeed;
                    const newVelocity = Vector.mult(currentVelocity, dampeningFactor);
                    Body.setVelocity(ball, newVelocity);
                } else if (currentSpeed < BASE_SPEED * 0.95 && currentSpeed > 0) {
                     // Minor acceleration back to BASE_SPEED if too slow
                    const boostFactor = (BASE_SPEED) / currentSpeed;
                    const newVelocity = Vector.mult(currentVelocity, boostFactor);
                    Body.setVelocity(ball, newVelocity);
                }
                
                // Keep speed capped at KICK_SPEED for safety
                if (currentSpeed > KICK_SPEED) {
                    const cappedVelocity = Vector.mult(Vector.normalise(currentVelocity), KICK_SPEED);
                    Body.setVelocity(ball, cappedVelocity);
                }
            };

            checkSpeed(ball1);
            checkSpeed(ball2);
        };
        
        // --- COLLISION LOGIC ---
        const collisionStartHandler = function(event) {
            if (isGameOver) return;

            const pairs = event.pairs;

            pairs.forEach(pair => {
                const labels = [pair.bodyA.label, pair.bodyB.label];
                const isItemCollision = labels.includes('sword');
                const isBallCollision = labels.includes('ball1') && labels.includes('ball2');

                // 1. Item Pickup (Sword)
                if (isItemCollision && (labels.includes('ball1') || labels.includes('ball2'))) {
                    // FIX: Sword was correctly picked up before. The issue was dynamic.
                    const takerBall = pair.bodyA.label.startsWith('ball') ? pair.bodyA : pair.bodyB;
                    
                    playerInfo.ball1.hasSword = (takerBall === ball1);
                    playerInfo.ball2.hasSword = (takerBall === ball2);
                    
                    Composite.remove(world, currentItem);
                    itemEmojiDiv.style.display = 'none';
                    currentItem = null;
                    itemSpawnTimer = setTimeout(spawnItem, ITEM_RESPAWN_TIME);
                }

                // 2. Ball Collision (Damage & Kick)
                if (isBallCollision) {
                    const p1 = playerInfo.ball1;
                    const p2 = playerInfo.ball2;

                    let damageDealt = false;
                    let damagedPlayer = null;
                    let damagedBall = null;

                    if (p1.hasSword && !p2.hasSword) {
                        p2.health--;
                        p1.hasSword = false;
                        damageDealt = true;
                        damagedPlayer = p2;
                        damagedBall = ball2;
                    } else if (p2.hasSword && !p1.hasSword) {
                        p1.health--;
                        p2.hasSword = false;
                        damageDealt = true;
                        damagedPlayer = p1;
                        damagedBall = ball1;
                    } else if (p1.hasSword && p2.hasSword) {
                        p1.hasSword = false;
                        p2.hasSword = false;
                    }
                    
                    if (damageDealt) {
                        playRandomKnifeSound(); 
                        
                        updateHealthBar(p1, p1.health, p2, p2.health);
                        
                        damagedPlayer.photoDiv.classList.add('hit-effect');
                        removeHitEffect(damagedPlayer);

                        // KICK EFFECT (Apply temporary speed up)
                        applyKick(damagedBall, KICK_DURATION);
                    }
                }
            });
        };

        function removeHitEffect(player) {
            setTimeout(() => {
                player.photoDiv.classList.remove('hit-effect');
            }, 300);
        }

        function spawnItem() {
            if (isGameOver) return;
            const size = 15;
            // Spawn closer to center to keep it accessible
            const x = Math.random() * (arenaWidth - 200) + 100;
            const y = Math.random() * (arenaHeight - 200) + 100;
            
            currentItem = Bodies.circle(x, y, size, { 
                isStatic: true, 
                isSensor: true, 
                label: 'sword', 
                render: { fillStyle: 'transparent' } 
            });
            Composite.add(world, currentItem);
            
            itemEmojiDiv.style.left = `${x}px`;
            itemEmojiDiv.style.top = `${y}px`;
            itemEmojiDiv.style.display = 'block';
        }

        function endGame(winner) {
            isGameOver = true;
            Runner.stop(runner);
            clearTimeout(itemSpawnTimer);
            clearTimeout(kickTimer1);
            clearTimeout(kickTimer2);

            document.getElementById('p1-sword-container').style.display = 'none';
            document.getElementById('p2-sword-container').style.display = 'none';


            winnerText.textContent = `${winner.name} Wins!`;
            winnerEmoji.textContent = winner.emoji;
            document.getElementById('game-over-modal').style.display = 'flex';
        }


        // --- UI & CUSTOMIZATION LOGIC ---

        function handleFileChange(event, player) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    player.texture = e.target.result;
                    document.getElementById(`${player.id.replace('ball', 'p')}-preview`).style.backgroundImage = `url(${e.target.result})`;
                    checkSetupComplete();
                };
                reader.readAsDataURL(file);
            }
        }
        
        function checkSetupComplete() {
            const p1Name = document.getElementById('p1-name-input').value.trim();
            const p2Name = document.getElementById('p2-name-input').value.trim();
            
            if (p1Name && p2Name) {
                document.getElementById('start-custom-game-button').disabled = false;
            } else {
                document.getElementById('start-custom-game-button').disabled = true;
            }
        }

        function setupGameAndStart() {
            playerInfo.ball1.name = document.getElementById('p1-name-input').value.trim() || 'Player 1';
            playerInfo.ball2.name = document.getElementById('p2-name-input').value.trim() || 'Player 2';
            
            document.getElementById('setup-modal').style.display = 'none';
            initializeGame();
        }

        // --- EVENT LISTENERS ---
        document.getElementById('p1-name-input').addEventListener('input', checkSetupComplete);
        document.getElementById('p2-name-input').addEventListener('input', checkSetupComplete);
        document.getElementById('p1-file').addEventListener('change', (e) => handleFileChange(e, playerInfo.ball1));
        document.getElementById('p2-file').addEventListener('change', (e) => handleFileChange(e, playerInfo.ball2));
        document.getElementById('start-custom-game-button').addEventListener('click', setupGameAndStart);
        document.getElementById('customize-button').addEventListener('click', () => document.getElementById('setup-modal').style.display = 'flex');
        document.getElementById('restart-button').addEventListener('click', () => {
            document.getElementById('game-over-modal').style.display = 'none';
            initializeGame();
        });
        document.getElementById('new-game-button').addEventListener('click', () => {
            document.getElementById('game-over-modal').style.display = 'none';
            document.getElementById('setup-modal').style.display = 'flex';
        });

        // Initial setup check and arena observation
        checkSetupComplete(); 
        const resizeObserver = new ResizeObserver(entries => {
            if (isGameOver) return;
            const oldArenaWidth = arenaWidth;
            const oldArenaHeight = arenaHeight;
            updateArenaSize();
            // Reposition balls proportionally on resize
            if (ball1 && ball2 && oldArenaWidth > 0 && oldArenaHeight > 0) {
                const scaleX = arenaWidth / oldArenaWidth;
                const scaleY = arenaHeight / oldArenaHeight;
                Body.setPosition(ball1, { x: ball1.position.x * scaleX, y: ball1.position.y * scaleY });
                Body.setPosition(ball2, { x: ball2.position.x * scaleX, y: ball2.position.y * scaleY });
            }
        });
        resizeObserver.observe(gameContainer);
    </script>
</body>
</html>
