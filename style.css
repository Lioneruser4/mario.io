const grid = document.getElementById('game-grid');
const scoreDisplay = document.getElementById('score');
const width = 8; // 8x8 ölçüsündə oyun sahəsi
const squareCount = width * width;
const squares = [];
let score = 0;

let itemBeingDragged;
let itemBeingReplaced;

// 47 fərqli meyvə şəkli üçün array yaradırıq
// Şəkil fayllarının adları: photos/photo(1).png - photos/photo(47).png
const fruitImages = [];
for (let i = 1; i <= 47; i++) {
    fruitImages.push(`photos/photo(${i}).png`);
}

// Oyunda istifadə ediləcək təsadüfi 8 fərqli meyvəni seçirik (Candy Crush standartı kimi)
// 47 fərqli meyvə oyunu çox çətinləşdirəcəkdi.
const gameItems = getRandomItems(fruitImages, 8); 

console.log('Meyvə Sürüşdürmə Oyunu yükləndi. Seçilən meyvə sayı:', gameItems.length);

// Təsadüfi elementləri seçmək üçün köməkçi funksiya
function getRandomItems(arr, num) {
    const shuffled = [...arr].sort(() => 0.5 - Math.random());
    return shuffled.slice(0, num);
}

// 1. Oyun Taxtasını Yaratmaq
function createBoard() {
    // Gridin tam ölçüsünə uyğun kvadrat ölçüsü
    const squareSize = 100 / width; 
    
    // CSS Grid üçün dinamik sütun sayı
    grid.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
    grid.style.gridTemplateRows = `repeat(${width}, 1fr)`;

    for (let i = 0; i < squareCount; i++) {
        const square = document.createElement('div');
        square.setAttribute('id', i);
        square.classList.add('square');

        // Ölçüləri quraşdırın (hər bir kvadratın eni və hündürlüyü)
        square.style.width = `${squareSize}%`;
        square.style.height = `${squareSize}%`;

        // Təsadüfi meyvə şəkli seçin
        let randomItemIndex = Math.floor(Math.random() * gameItems.length);
        const imageUrl = gameItems[randomItemIndex];
        
        // Şəkil faylının yolunu background-image olaraq əlavə edirik
        square.style.backgroundImage = `url('${imageUrl}')`;
        // Şəklin adını data atributuna qeyd edirik (Match yoxlaması üçün)
        square.setAttribute('data-item', imageUrl);

        // Drag & Drop (Masaüstü) və Touch (Mobil) hadisələrini əlavə edin
        addEventListeners(square);

        grid.appendChild(square);
        squares.push(square);
    }
}

// Mobil və Masaüstü üçün Hadisə Dinləyiciləri
function addEventListeners(square) {
    // Masaüstü (Drag & Drop)
    square.setAttribute('draggable', true);
    square.addEventListener('dragstart', dragStart);
    square.addEventListener('dragover', dragOver);
    square.addEventListener('dragenter', dragEnter);
    square.addEventListener('dragleave', dragLeave);
    square.addEventListener('drop', dragDrop);
    square.addEventListener('dragend', dragEnd);

    // Mobil Cihazlar (Touch Events)
    square.addEventListener('touchstart', touchStart);
    // TouchMove və TouchEnd hadisələri daha effektiv işləyəcək şəkildə dəyişdirildi
}

// 2. Drag & Drop Məntiqi (Sürüşdürmə)

// Drag Hadisələri (Masaüstü)
function dragStart(e) {
    itemBeingDragged = this;
    this.classList.add('drag-start'); 
}

function dragOver(e) {
    e.preventDefault();
}

function dragEnter(e) {
    e.preventDefault();
}

function dragLeave() {
    
}

function dragDrop(e) {
    itemBeingReplaced = this;
    e.preventDefault();
}

function dragEnd() {
    this.classList.remove('drag-start');

    if (!itemBeingReplaced) return;

    const dragId = parseInt(itemBeingDragged.id);
    const replaceId = parseInt(itemBeingReplaced.id);

    // Dəyişməyə icazə verilən qonşu indeksləri yoxlayır
    const validMoves = [
        dragId - 1,
        dragId + 1,
        dragId + width,
        dragId - width
    ];

    // Qonşu xanaya sürüşdürməni yoxlayır
    if (validMoves.includes(replaceId)) {
        // İki xananın background-image və data-item dəyərlərini dəyişdirin
        const draggedItemUrl = itemBeingDragged.style.backgroundImage;
        const replacedItemUrl = itemBeingReplaced.style.backgroundImage;

        const draggedData = itemBeingDragged.getAttribute('data-item');
        const replacedData = itemBeingReplaced.getAttribute('data-item');

        itemBeingReplaced.style.backgroundImage = draggedItemUrl;
        itemBeingReplaced.setAttribute('data-item', draggedData);
        
        itemBeingDragged.style.backgroundImage = replacedItemUrl;
        itemBeingDragged.setAttribute('data-item', replacedData);

        // Uyğunluqları yoxlayın
        let isMatch = checkAllMatches(); 

        // Əgər uyğunluq yoxdursa, dəyişikliyi geri qaytarın
        if (!isMatch) {
            itemBeingReplaced.style.backgroundImage = replacedItemUrl;
            itemBeingReplaced.setAttribute('data-item', replacedData);
            itemBeingDragged.style.backgroundImage = draggedItemUrl;
            itemBeingDragged.setAttribute('data-item', draggedData);
        }
    }

    itemBeingDragged = null;
    itemBeingReplaced = null;
}

// Touch Hadisələri (Mobil)
let startTouchSquare = null;

function touchStart(e) {
    e.preventDefault();
    startTouchSquare = this;
    this.classList.add('drag-start');
}

function touchEnd(e) {
    if (!startTouchSquare) return;

    startTouchSquare.classList.remove('drag-start');
    
    // Toxunuşun bitdiyi yeri tapmaq üçün
    const touch = e.changedTouches[0];
    const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);

    // Əgər toxunuş eyni kvadratda bitibsə, qonşu xanada bitdiyini tapmaq üçün əlavə məntiq lazımdır.
    // Lakin, biz burada sürüşdürmə deyil, toxunub-sürüşdürüb-buraxma kimi bir mexanizmi tətbiq edirik.

    // Qonşu kvadratı tapmaq üçün koordinatlardan istifadə etmək daha yaxşıdır
    // Əgər toxunuş fərqli bir element üzərində bitirsə:
    if (targetElement && targetElement.classList.contains('square') && targetElement !== startTouchSquare) {
        itemBeingDragged = startTouchSquare;
        itemBeingReplaced = targetElement;

        const dragId = parseInt(itemBeingDragged.id);
        const replaceId = parseInt(itemBeingReplaced.id);

        const validMoves = [
            dragId - 1,
            dragId + 1,
            dragId + width,
            dragId - width
        ];
        
        if (validMoves.includes(replaceId)) {
            // Dəyişmə məntiqini tətbiq edin (DragEnd-dəki kimi)
            const draggedItemUrl = itemBeingDragged.style.backgroundImage;
            const replacedItemUrl = itemBeingReplaced.style.backgroundImage;

            const draggedData = itemBeingDragged.getAttribute('data-item');
            const replacedData = itemBeingReplaced.getAttribute('data-item');

            itemBeingReplaced.style.backgroundImage = draggedItemUrl;
            itemBeingReplaced.setAttribute('data-item', draggedData);
            
            itemBeingDragged.style.backgroundImage = replacedItemUrl;
            itemBeingDragged.setAttribute('data-item', replacedData);
            
            let isMatch = checkAllMatches();

            if (!isMatch) {
                itemBeingReplaced.style.backgroundImage = replacedItemUrl;
                itemBeingReplaced.setAttribute('data-item', replacedData);
                itemBeingDragged.style.backgroundImage = draggedItemUrl;
                itemBeingDragged.setAttribute('data-item', draggedData);
            }
        }
    }

    startTouchSquare = null;
    itemBeingDragged = null;
    itemBeingReplaced = null;
}


// 3. Uyğunluqları Yoxlamaq (Match Checking)

// Xal əlavə etmək funksiyası
function addScore(count) {
    score += count * 10; // Hər partlayan meyvə üçün 10 xal
    scoreDisplay.innerHTML = score;
}

// Bütün uyğunluqları yoxlayıb partladan əsas funksiya
function checkAllMatches() {
    let matchFound = false;
    matchFound = checkRowForThree() || matchFound;
    matchFound = checkColumnForThree() || matchFound;
    
    // Əgər 4 və ya 5 ard-arda uyğunluq olarsa, burada əlavə yoxlama və xal artırma edilməlidir.
    // Sadəlik üçün yalnız 3-lülər yoxlanılır.
    
    return matchFound;
}

// Ard-arda 3 uyğunluğu yoxlamaq (Sətirlər üçün)
function checkRowForThree() {
    let matchFound = false;
    for (let i = 0; i < squareCount - 2; i++) {
        // Sətrin son 2 xanasını yoxlamadan keçir (sətrin kənarıdır)
        const isEndOfRow = [width - 2, width - 1].includes(i % width); 

        if (isEndOfRow) continue;

        const firstItem = squares[i].getAttribute('data-item');
        const secondItem = squares[i + 1].getAttribute('data-item');
        const thirdItem = squares[i + 2].getAttribute('data-item');
        
        // Boş olmayan və 3 ard-arda eyni olan xanaları tapın
        if (firstItem && firstItem === secondItem && secondItem === thirdItem && !squares[i].classList.contains('is-blank')) {
            // Patlama üçün is-blank klassını əlavə edin
            squares[i].classList.add('is-blank');
            squares[i + 1].classList.add('is-blank');
            squares[i + 2].classList.add('is-blank');
            addScore(3);
            matchFound = true;
        }
    }
    return matchFound;
}

// Alt-alta 3 uyğunluğu yoxlamaq (Sütunlar üçün)
function checkColumnForThree() {
    let matchFound = false;
    for (let i = 0; i < squareCount - (width * 2); i++) {
        const firstItem = squares[i].getAttribute('data-item');
        const secondItem = squares[i + width].getAttribute('data-item');
        const thirdItem = squares[i + width * 2].getAttribute('data-item');

        if (firstItem && firstItem === secondItem && secondItem === thirdItem && !squares[i].classList.contains('is-blank')) {
            // Patlama üçün is-blank klassını əlavə edin
            squares[i].classList.add('is-blank');
            squares[i + width].classList.add('is-blank');
            squares[i + width * 2].classList.add('is-blank');
            addScore(3);
            matchFound = true;
        }
    }
    return matchFound;
}

// 4. Meyvələri Düşürmək və Yeni Meyvələri Yaratmaq

function moveDown() {
    for (let i = squareCount - 1 - width; i >= 0; i--) { // Aşağıdan yuxarı yoxlayın
        if (squares[i + width].classList.contains('is-blank')) {
            // Aşağıdakı boş xanaya yuxarıdakı meyvəni köçürün
            squares[i + width].style.backgroundImage = squares[i].style.backgroundImage;
            squares[i + width].setAttribute('data-item', squares[i].getAttribute('data-item'));
            squares[i + width].classList.remove('is-blank');
            
            // Yuxarıdakı xananı boşaldın
            squares[i].style.backgroundImage = '';
            squares[i].setAttribute('data-item', '');
            squares[i].classList.add('is-blank');
        }
    }

    // Ən yuxarı sətirdəki boş yerləri yeni meyvələrlə doldurun
    for (let i = 0; i < width; i++) {
        if (squares[i].classList.contains('is-blank')) {
            let randomItemIndex = Math.floor(Math.random() * gameItems.length);
            const imageUrl = gameItems[randomItemIndex];
            
            squares[i].style.backgroundImage = `url('${imageUrl}')`;
            squares[i].setAttribute('data-item', imageUrl);
            squares[i].classList.remove('is-blank');
        }
    }
}

// 5. Oyun Dövrü (Game Loop)

function gameLoop() {
    moveDown(); // Meyvələri aşağı salın və yenilərini yaradın
    
    // Bütün uyğunluqları yoxlayın. Əgər yeni uyğunluq tapılarsa, proses təkrarlanmalıdır.
    let hasNewMatches = checkAllMatches();

    if (hasNewMatches) {
        // Animasiyaya vaxt vermək üçün bir az gecikmə ilə dövrü təkrarlayın
        setTimeout(gameLoop, 200); 
    }
}

createBoard();
// Əsas dövrü hər 100ms-də işə salın
setInterval(gameLoop, 100); 

// Qeyd: Bu kod 4 və 5 ard-arda uyğunluqları yoxlamır, yalnız 3-ləri yoxlayır.
// Daha mürəkkəb oyun qaydaları üçün checkRowForThree və checkColumnForThree funksiyaları təkmilləşdirilməlidir.
